"use strict";

var game = {};
var main = function() {

    var googleAuth2;




    function ordinalSuffix(i) {
        var j = i % 10,
            k = i % 100;
        if (j == 1 && k != 11) {
            return i + "st";
        }
        if (j == 2 && k != 12) {
            return i + "nd";
        }
        if (j == 3 && k != 13) {
            return i + "rd";
        }
        return i + "th";
    }






    (function () {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function (callback, element) {
                var currTime = Date.now(), timeToCall = Math.max(0, frame_time - (currTime - lastTime));
                var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function (id) { clearTimeout(id); };
        }
        if (!window.requestIdleCallback) {
            window.requestIdleCallback = function (callback) { callback(); };
        }
        if (!window.cancelIdleCallback) {
            window.cancelIdleCallback = function () {};
        }
    }());

// (4.22208334636).fixed(n) will return fixed point value to n places, default n = 3
    Number.prototype.fixed = function (n) { n = n || 3; return parseFloat(this.toFixed(n)); };

    var getRandomInt = function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    var getRandomFloat = function(min, max) {
        return Math.random() * (max - min + 1) + min;
    }


    var lerp = function (p, n, t) {
        var _t = Number(t); _t = Math.max(0, Math.min(1, _t));
        let res = p + _t * (n - p);
        if (isNaN(res)) {
            return p;
        } else {
            return res;
        }
    };

    var Eps = 1E-4;


    var debugPoints = [];
    var debugLines = [];

    class Coord {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        static read(dataReader) {
            return new Coord(dataReader.readInt16(), dataReader.readInt16());
        }

        write(dataWriter) {
            dataWriter.writeInt16(this.x);
            dataWriter.writeInt16(this.y);
        }

        angle(){
            return Math.atan2(this.y, this.x);
        }

        toP2vec(){
            return [this.x, this.y];
        }

        static fromP2Vec(p2vec){
            return new Coord(p2vec[0], p2vec[1]);
        }

        copy() {
            return new Coord(this.x, this.y);
        }

        static convert(obj) {
            return new Coord(obj.x, obj.y);
        }

        add(other) {
            return new Coord(this.x + other.x, this.y + other.y);
        }

        sub(other) {
            return new Coord(this.x - other.x, this.y - other.y);
        }

        mul_scalar(r) {
            return new Coord(this.x * r, this.y * r);
        }

        lerp(other, t) {
            return new Coord(lerp(this.x, other.x, t), lerp(this.y, other.y, t))
        }

        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }

        normal() {
            var length = this.length();
            if (length < Eps) {
                return new Coord(0, 0);
            }
            return this.mul_scalar(1.0 / length);
        }

        ortho() {
            return new Coord(this.y, -this.x);
        }

        crossProd(other) {
            return this.x * other.y - this.y * other.x;
        }

        dist(other) {
            return this.sub(other).length();
        }

        near(other) {
            return this.dist(other) < Eps;
        }

        static lineLineIntersection(a, b, c, d) { //ab = segment1, cd = segment2
            //http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect

            var p = a;
            var r = b.sub(a);
            var q = c;
            var s = d.sub(c);

            var rxs = r.crossProd(s);

            if (Math.abs(rxs) < Eps) {
                return; //P�rhuzamos vagy egy egyenesre esik, ak�r �t is fedhetik egym�st! Egyel�re ilyen esetben nem h�vodhat.
            }

            var t = q.sub(p).crossProd(s) / rxs;
            var u = q.sub(p).crossProd(r) / rxs;

            var crossPoint = p.add(r.mul_scalar(t));

            return { crossPoint: crossPoint, t: t, u: u };
        }

        static vectorCircleIntersection(beg, end, c, r) {
            var a = beg;
            var b = end;

            var ab = b.sub(a);
            var cd = ab.ortho().normal().mul_scalar(r);
            var d1 = c.add(cd);
            var d2 = c.sub(cd);
            var inter = Coord.lineLineIntersection(a, b, d1, d2);
            if (!inter) {
                return;
            }
            var e = inter.crossPoint;
            if (e.dist(c) > r) {
                return;
            }

            //debugPoints.push(e);
            //debugLines.push({ beg: c, dir: e.sub(c).normal() });

            var aeDist = e.dist(a);
            var ceDist = e.dist(c);
            var efDist = Math.sqrt(r * r - ceDist * ceDist);
            var f = e.sub(ab.normal().mul_scalar(efDist));
            var g = e.add(ab.normal().mul_scalar(efDist));

            return { beg: f, end: g };
        }

        insideRect (leftBottom, rightTop) {
            return this.x >= leftBottom.x && this.y >= leftBottom.y && this.x <= rightTop.x && this.y <= rightTop.y;
        }

        static circleInsideRect (c, r, leftBottom, rightTop) {
            var leftBottomInflated = leftBottom.sub(new Coord(r , r));
            var rightTopInflated = rightTop.add(new Coord(r , r));
            return c.insideRect(leftBottomInflated, rightTopInflated);
        }

        static rectRectOverlap(leftBottom1, rightTop1, leftBottom2, rightTop2) {
            if (rightTop1.x < leftBottom2.x || rightTop1.y < leftBottom2.y || leftBottom1.x > rightTop2.x || leftBottom1.y > rightTop2.y) {
                return false;
            }
            return true;

        }
    }


    var drawDebug = function (ctx) {
        ctx.save()

        ctx.fillStyle = "#FF00FF";
        debugPoints.forEach(p => {
            ctx.fillRect(p.x - 2.0, p.y - 2.0, 4, 4);
        });

        debugLines.forEach(line => {
            ctx.strokeStyle = "#FF00FF";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(line.beg.x, line.beg.y);
            var end = line.beg.add(line.dir.mul_scalar(50));
            ctx.lineTo(end.x, end.y);

            ctx.stroke();

        });

        ctx.restore();
    }

    var getAngleDiff = function(target, base) {
        let angDiff = target - base;
        angDiff %= Math.PI * 2;
        if (angDiff > Math.PI) {
            angDiff = angDiff - 2 * Math.PI;
        } else if (angDiff < -Math.PI) {
            angDiff = angDiff + 2 * Math.PI;
        }
        return angDiff;
    }

    class PlayerState {
        constructor(pos, angle) {
            this.pos = pos.copy();
            this.angle = angle;
        }

        static fromServerData(column) {
            return new PlayerState(Coord.convert(column.pos), column.angle);
        }

        copy() {
            return new PlayerState(this.pos, this.angle);
        }

        interpolate(other, t) {
            let pos = this.pos.lerp(other.pos, t);

            let angDiff = getAngleDiff(other.angle, this.angle);
            let angle = lerp(this.angle, this.angle + angDiff, t);

            return new PlayerState(
                pos,
                angle
            );
        }
    }

    var UserPriviliges = {
        None: 0,
        Chat: 1,
        Kick: 2,
        Ban: 4,
        ServerOwner: 8,
        Commentator: 16
    }

    var BasicUser = UserPriviliges.Chat;
    var Admin = BasicUser | UserPriviliges.Kick | UserPriviliges.Ban;

    var RankType = [
        { nickname: "Guest"},
        { nickname: "Potato Pleb",        score: 0},
        { nickname: "Bronze Casual", 	    score: 100},
        { nickname: "Silver Scrub", 	    score: 250},
        { nickname: "Gold Garbage",       score: 500},
        { nickname: "Platinum Peasant",   score: 750},
        { nickname: "Diamond Dumpster",   score: 1000},
        { nickname: "Spacemonkey",        score: 1250},
        { nickname: "Cosmic Cadet",  	    score: 1500},
        { nickname: "Astrojunkie",        score: 1750},
        { nickname: "Starchild",		    score: 2000},
        { nickname: "Starman",  		    score: 2250},
        { nickname: "Starlord",	        score: 2500},
        { nickname: "Celestial",	        score: 2750},
        { nickname: "Master",             score: 3000},
        { nickname: "Grandmaster",        score: 4000}
    ];

    function getRankColor(rank) {
        if (rank <= 5) {
            return "#36edc9";
        } else if (rank <= 10) {
            return "#43f9f3";
        } else if (rank <= 15) {
            return "#ffe169";
        } else return "#fd3051";
    }

    function getRarityName(r) {
        switch (r) {
            case 1: return "common"; break;
            case 2: return "uncommon"; break;
            case 3: return "rare"; break;
            case 4: return "epic"; break;
            case 5: return "legendary"; break;
            case 6: return "unique"; break;
            default: return "unknown";
        }
    }

    function getRarityColor(r) {
        switch (r) {
            case 1: return "#2d899d"; break;
            case 2: return "#36edc9"; break;
            case 3: return "#0070ff"; break;
            case 4: return "#832090"; break;
            case 5: return "#ffe169"; break;
            case 6: return "#fd3051"; break;
            default: return "#2D899D";
        }
    }


    var InventoryFilter = {
        None: 0,
        Stick: 1,
        Avatar: 2,
        Decal: 4,
        Goalie: 8,
        Misc: 16
    }

    class PlayerInfo {
        constructor() {
            this.userName = '';
            this.privilige = BasicUser;
            this.privilige = 1;
            this.rank = 0;
            this.score = 0;
            this.color = 1;

            this.maxWinStreak = 0;
            this.maxLoseStreak = 0;
            this.playTime = 0;
            this.avatar = 0;
            this.wins = 0;
            this.losses = 0;
            this.fouls = 0;

            this.stick = 1;
            this.decal = 10;
            this.felt = 1;

            this.registered = Date.now();
            this.lastLogin = Date.now();
            this.country ="us";
            this.guid = "";
        }

        getScoreChange(otherRank, isWinner) {
            let rankDiff = this.rank - otherRank;
            let isGuest = this.rank == 0 || otherRank == 0;


            if (isWinner) {
                var d = 40 - rankDiff * 5;
                d = Math.max(1, d);
                d = Math.min(isGuest ? 20 : 80, d);
                return d;
            } else {
                var d = -40 - rankDiff * 5;
                d = Math.min(-1, d);
                d = Math.max(isGuest ? -20 : -80, d);
                return d;
            }
        }

        calcRank(score) {
            for (var i = 1; i < RankType.length; i++) {
                if (i == RankType.length - 1) {
                    return i;
                }
                if (RankType[i + 1].score  > score && RankType[i].score  <= score) {
                    return i;
                }
            }
        }

        addScore(amount) {
            this.score = Math.max(0, this.score+amount);
            if (this.rank > 0) {
                this.rank = this.calcRank(this.score);
            }
        }

        get size() {
            return (22 + // fields
                4 + //playTime
                4 + //stick
                4 + //decal
                4 + //felt
                this.userName.length*4 + 4 +
                this.country.length*4 + 4 +
                this.guid.length*4 + 4);
        }

        static fromData(column) {
            let playerInfo = new PlayerInfo();
            playerInfo.userName = column.userName;
            playerInfo.privilige = column.privilige;
            playerInfo.rank = column.rank;
            playerInfo.score = column.score;
            playerInfo.color = column.color;
            playerInfo.maxWinStreak = column.maxWinStreak;
            playerInfo.maxLoseStreak = column.maxLoseStreak;
            playerInfo.playTime = column.playTime;
            playerInfo.avatar = column.avatar;
            playerInfo.wins = column.wins;
            playerInfo.losses = column.losses;
            playerInfo.fouls = column.fouls;
            playerInfo.stick = column.stick;
            playerInfo.decal = column.decal;
            playerInfo.felt = column.felt;
            playerInfo.registered = column.registered;
            playerInfo.lastLogin = column.lastLogin;
            playerInfo.country = column.country;
            playerInfo.guid = column.guid;
            return playerInfo;
        }

        write(dataWriter) {
            dataWriter.writeUint8(this.privilige);
            dataWriter.writeUint8(this.rank);
            dataWriter.writeUint32(this.score);
            dataWriter.writeUint8(this.color);
            dataWriter.writeUint8(this.maxWinStreak);
            dataWriter.writeUint8(this.maxLoseStreak);
            dataWriter.writeFloat32(this.playTime);
            dataWriter.writeUint8(this.avatar);
            dataWriter.writeUint32(this.wins);
            dataWriter.writeUint32(this.losses);
            dataWriter.writeUint32(this.fouls);
            dataWriter.writeUint32(this.stick);
            dataWriter.writeUint32(this.decal);
            dataWriter.writeUint32(this.felt);
            dataWriter.writeString(this.userName);
            dataWriter.writeString(this.country);
            dataWriter.writeString(this.guid);
        }

        read(dataReader) {
            this.privilige = dataReader.readUint8();
            this.rank = dataReader.readUint8();
            this.score = dataReader.readUint32();
            this.color = dataReader.readUint8();
            this.maxWinStreak = dataReader.readUint8();
            this.maxLoseStreak = dataReader.readUint8();
            this.playTime = dataReader.readFloat32();
            this.avatar = dataReader.readUint8();
            this.wins = dataReader.readUint32();
            this.losses = dataReader.readUint32();
            this.fouls = dataReader.readUint32();
            this.stick = dataReader.readUint32();
            this.decal = dataReader.readUint32();
            this.felt = dataReader.readUint32();
            this.userName = dataReader.readString();
            this.country = dataReader.readString();
            this.guid = dataReader.readString();
        }
    }

    var currentZoom = 1;

    var Config = {
        clientInputRate: 1000 / 20,
        clientFrameTime: 1000 / 60,
        serverFrameTime: 1000 / 200,

        interpolationRate: 0.3,

        minZoom: 0.45,
        maxZoom: 2,

        mouseControlMinDist: 17,
        mouseControlMaxDist: 34,

        canvasRes: 1,

        maxSpeed: 650
    };


    class DataReader {
        constructor(arrayBuffer) {
            this.dataView = new DataView(arrayBuffer);
            this.byteOffset = 0;
        }

        step(bytes) {
            this.byteOffset += bytes;
        }

        readInt8() {
            let value = this.dataView.getInt8(this.byteOffset);
            this.byteOffset++;
            return value;
        }

        readUint8() {
            let value = this.dataView.getUint8(this.byteOffset);
            this.byteOffset++;
            return value;
        }

        readInt16() {
            let value = this.dataView.getInt16(this.byteOffset);
            this.byteOffset += 2;
            return value;
        }

        readUint16() {
            let value = this.dataView.getUint16(this.byteOffset);
            this.byteOffset += 2;
            return value;
        }

        readInt32() {
            let value = this.dataView.getInt32(this.byteOffset);
            this.byteOffset += 4;
            return value;
        }

        readUint32() {
            let value = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4;
            return value;
        }

        readFloat32() {
            let value = this.dataView.getFloat32(this.byteOffset);
            this.byteOffset += 4;
            return value;
        }

        readFloat64() {
            let value = this.dataView.getFloat64(this.byteOffset);
            this.byteOffset += 8;
            return value;
        }

        readString() {
            if (this.dataView.length < this.dataView.byteOffset + 4) {
                return "";
            }

            let strLength = this.readFloat32();
            if (this.dataView.length < this.dataView.byteOffset + strLength * 4) {
                return "";
            }

            let arr = [];
            for(var i = 0; i<strLength; ++i) {
                arr.push(this.readFloat32());
            }
            return String.fromCharCode.apply(String, arr);
            // if (/[\u0080-\uffff]/.test(str)) {
            // 	return { str: "", offset: offset };
            // }
        }

        readFlags() {
            let byte = this.readUint8();
            let flags = new Array(8);
            for (let i = 0; i < 8; i++) {
                flags[i] = byte & Math.pow(2, i);
            }
            return flags;
        }

        readAngle() {
            let angle = this.readInt16();
            return angle * Math.PI / 1280;
        }
    }

    class DataWriter {
        constructor(arrayBuffer) {
            this.dataView = new DataView(arrayBuffer);
            this.byteOffset = 0;
        }

        step(bytes) {
            this.byteOffset += bytes;
        }

        writeInt8(value) {
            this.dataView.setInt8(this.byteOffset, value);
            this.byteOffset++;
        }

        writeUint8(value) {
            this.dataView.setUint8(this.byteOffset, value);
            this.byteOffset++;
        }

        writeInt16(value) {
            this.dataView.setInt16(this.byteOffset, value);
            this.byteOffset += 2;
        }

        writeUint16(value) {
            this.dataView.setUint16(this.byteOffset, value);
            this.byteOffset += 2;
        }

        writeInt32(value) {
            this.dataView.setInt32(this.byteOffset, value);
            this.byteOffset += 4;
        }

        writeUint32(value) {
            this.dataView.setUint32(this.byteOffset, value);
            this.byteOffset += 4;
        }

        writeFloat32(value) {
            this.dataView.setFloat32(this.byteOffset, value);
            this.byteOffset += 4;
        }

        writeFloat64(value) {
            this.dataView.setFloat64(this.byteOffset, value);
            this.byteOffset += 8;
        }

        writeString(str) {
            // if(/[\u0080-\uffff]/.test(str)){
            // 	return;
            // }
            this.writeFloat32(str.length);
            for(var i=0; i < str.length; i++) {
                this.writeFloat32(str.charCodeAt(i));
            }
        }

        writeFlags(flags) {
            if (flags.length > 8) {
                throw "too many flags";
            }
            let byte = 0;
            flags.forEach((flag, i) => {
                if (flag) {
                    byte = byte | Math.pow(2, i);
                }
            });
            this.writeUint8(byte);
        }

        writeAngle(angle) {
            angle %= Math.PI * 2;
            if (angle > Math.PI) {
                angle -= Math.PI * 2;
            } else if (angle < -Math.PI) {
                angle += Math.PI * 2;
            }
            angle = angle * 1280 / Math.PI;
            this.writeInt16(angle);
        }
    }

    class SoundInstance {
        constructor(soundEngine, source, nickname, id) {
            this.id = soundEngine.ids++;
            this.source = source;
            this.nickname = nickname;
            this.gainNode = soundEngine.context.createGain();
//		this.panNode = soundEngine.context.createStereoPanner();
            this.source.connect(this.gainNode);
            this.gainNode.connect(soundEngine.mainGainNode);
            //this.panNode.connect(soundEngine.mainGainNode);
        }

        play() {
            this.source.start(0);
        }

        stop() {
            this.source.stop();
        }

        setVolume(value) {
            this.gainNode.gain.value=value/100;
        }

        //setPan(value) {
        //	this.panNode.pan.value = value;
        //}

        setPlaybackRate(value) {
            this.source.playbackRate.value = value;
        }
    }


    class Sound {
        constructor(soundName, url) {
            this.soundName = soundName;
            this.url = url;
        }
    }

    class SoundEngine {
        constructor(assetManager) {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.context = new AudioContext();
            this.count = 0;
            this.soundList = [];
            this.ids = 1;
            this.instances = [];
            this.mainGainNode = this.context.createGain();
            this.volume = 50;
            this.mainGainNode.value = 1;
            this.soundsEnabled = true;
            this.mainGainNode.connect(this.context.destination);
            this.assetManager = assetManager;
        }

        setVolume(volume) {
            if (volume >= 0 && volume <= 100) {
                this.volume = volume;
                this.mainGainNode.gain.value = volume / 100;
            }
        }

        mute() {
            this.mainGainNode.gain.value = 0;
            this.soundsEnabled = false;
        }

        unmute() {
            this.setVolume(this.volume);
            this.soundsEnabled = true;
        }

        loadAudioBuffer(sound, callback) {
            // Load buffer asynchronously
            var request = new XMLHttpRequest();
            request.open("GET", sound.url, true);
            request.responseType = "arraybuffer";

            request.onload = () => {
                // Asynchronously decode the audio file column in request.response
                this.context.decodeAudioData(
                    request.response,
                    (buffer) => {
                        if (!buffer) {
                            alert('error decoding file column: ' + sound.url);
                            return;
                        }
                        sound.buffer = buffer;
                        if (callback)
                            callback();
                    },
                    function(error) {
                        console.error('decodeAudioData error', error);
                    }
                );
            }

            request.onerror = function() {
                alert('BufferLoader: XHR error');
            }

            request.send();
        }


        addSound(soundName, url) {
            this.soundList.push(new Sound(soundName, url));
        }

        removeInstance(id) {
            this.instances = this.instances.filter(s => s.id != id);
        }

        preloadSounds(callback) {
            this.soundList.forEach(s => {
                this.loadAudioBuffer(s, callback);
            })
        }

        playRandomSound(soundName, min, max) {
            var soundNum = getRandomInt(min, max);
            return this.playSound(soundName+soundNum, false, soundName);
        };

        playSound(soundName, loop, origName) {

            let sound = this.soundList.find(s=>s.soundName == soundName)
            if (sound && sound.buffer) {
                var source = this.context.createBufferSource();
                var soundInstance = new SoundInstance(this, source, origName ? origName : soundName);
                source.buffer = sound.buffer;
                source.onended = () => {
                    this.removeInstance(soundInstance.id);
                }
                if (loop) {
                    source.loop = true;
                }
                source.start(0);
                this.instances.push(soundInstance);
                return soundInstance;
            }
            return null;
        }

        loopSound(soundName) {
            return this.playSound(soundName, true);
        }

        update() {
        }
    }

    class Sprite {
        constructor() {

        }
    }

    class AnimatedSprite {
        constructor(spriteFrames) {
            this.frames = spriteFrames;

        }

    }


    class Player {
        constructor(game_instance, id, client_instance) {
            this.instance = client_instance;
            this.game = game_instance;

            //Set up initial values for our state information
            this.state = 'not-connected';

            this.clientId = client_instance ? this.instance.id : 0;
            this.id = id;
            this.playerInfo = new PlayerInfo();

            //Our local history of inputs
            this.resetInput();
            this.target = { x: 0, y: 0 };
            this.chatCooldown = 0;
        }

        resetInput() {
            this.input = this.prevInput = {};
        }
    }

    var BallTypes = {
        team0: 0,
        team1: 1,
        white: 2,
        puck: 3
    };

    class Ball {
        constructor(team) {
            this.team = team;
            this.r = this.puck ? 25 : 16;
            this.position = new Coord(0,0);
        }

        get puck() {
            return this.team == BallTypes.puck;
        }

        get white() {
            return this.team == BallTypes.white;
        }

        get x() {
            return this.position.x;
        }

        get y() {
            return this.position.y;
        }

        write(dataWriter) {
            dataWriter.writeFloat32(this.body.position[0]);
            dataWriter.writeFloat32(this.body.position[1]);
        }

        read(dataReader) {
            this.position.x = dataReader.readFloat32();
            this.position.y = dataReader.readFloat32();
        }

        init(stage, textures) {
            this.sprites = new PIXI.Container();
            textures.forEach(texture => {
                let sprite = new PIXI.Sprite(game.assetManager.getTexture(texture.texture));
                sprite.anchor.set(0.5, 0.5);
                if (texture.offset) {
                    sprite.position.set(texture.offset[0], texture.offset[1]);
                }
                if (texture.keep) {
                    sprite.keepColor = true;
                }
                this.sprites.addChild(sprite);
            });
            stage.addChild(this.sprites);
        }

        update() {
            let q = 0;
            if (this.pot) {
                let fadeTime = 160;
                q = (Date.now() - this.pot) / fadeTime;
                q *= q;
                if (q > 1) {
                    delete this.pot;
                }
            }

            this.sprites.alpha = 1 - q;
            this.sprites.scale.x = this.sprites.scale.y = 1 - 0.8 * q;
            if (this.sprites.alpha < 0) {
                this.sprites.visible = false;
            }
            this.sprites.x = lerp(this.sprites.x, this.position.x, Config.interpolationRate);;
            this.sprites.y = lerp(this.sprites.y, this.position.y, Config.interpolationRate);
        }

        reset() {
            delete this.pot;
            this.sprites.visible = true;
            this.sprites.alpha = 1;
            this.sprites.scale.x = this.sprites.scale.y = 1;
        }

        get size() {
            return 2*4;
        }
    }

    var circleLineIntersect = function(p0, angle, c, r) {
        let p = {
            x: p0.x - c.x,
            y: p0.y - c.y
        };

        let p2 = {
            x: p.x + Math.cos(angle),
            y: p.y + Math.sin(angle)
        };

        let dx = p2.x - p.x;
        let dy = p2.y - p.y;
        let dr = Math.sqrt(dx * dx + dy * dy);
        let D = p.x * p2.y - p2.x * p.y;

        let delta = r * r * dr * dr - D * D;
        if (delta >= 0) {
            let x1 = (D * dy + Math.sign(dy) * dx * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
            let x2 = (D * dy - Math.sign(dy) * dx * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
            let y1 = (-D * dx + Math.abs(dy) * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
            let y2 = (-D * dx - Math.abs(dy) * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);

            if ((p.x - x1) * (p.x - x1) + (p.y - y1) * (p.y - y1) < (p.x - x2) * (p.x - x2) + (p.y - y2) * (p.y - y2)) {
                return { x: x1 + c.x, y: y1 + c.y };
            } else {
                return { x: x2 + c.x, y: y2 + c.y };
            }
        }
    };

    var circleDirIntersect = function(p, angle, c0, r) {
        let vx = Math.cos(angle);
        let vy = Math.sin(angle);

        let a = vx * vx + vy * vy;
        let b = 2 * (p.x * vx + p.y * vy - vx * c0.x - vy * c0.y);
        let c = p.x * p.x + p.y * p.y + c0.x * c0.x + c0.y * c0.y - 2 * (p.x * c0.x + p.y * c0.y) - r * r;

        let D = b * b - 4 * a * c;
        if (D < 0)
            return;

        let sqrtD = Math.sqrt(D);

        let lamdba1 = (-b + sqrtD) / (2 * a);
        let lamdba2 = (-b - sqrtD) / (2 * a);
        let lambda = Math.max(0, Math.min(lamdba1, lamdba2));
        if (!lambda)
            return;

        return { x: p.x + lambda * vx, y: p.y + lambda * vy };
    };

    var rgbToHex = function(r, g, b) {
        return (r << 16) + (g << 8) + b;
    };

    class Tip {
        constructor() {
            this.container = document.createElement('div');
            this.container.style.position = "fixed";
            this.container.style.display = "none";
            this.container.style.pointerEvents ="none";
            this.container.style.alignItems = "center";
            this.container.style.justifyContent = "flex-end";

            this.icon = document.createElement('img');
            this.icon.src = 'assets/tips/ui_icon_tip.svg';
            this.icon.style.width = this.icon.style.height = "40px";
            this.icon.style.marginRight = "8px";
            this.container.appendChild(this.icon);

            this.span = document.createElement('span');
            this.span.style.color = 'white';
            this.span.style.fontSize = '20px';
            this.span.style.textAlign = 'right';
            this.container.appendChild(this.span);

            document.body.appendChild(this.container);
        }

        onResize() {
            let pos = game.modelToScreen(90, 626 + 8);
            this.container.style.right = pos.x + "px";
            this.container.style.top = pos.y + "px";
            this.container.style.maxWidth = ((1112 - 180) * game.table.scale) + "px";
        }

        setText(text, withIcon) {
            if (!text) {
                text = "";
            }

            this.previousText = this.text;
            this.text = text;
            this.prevWidthIcon = this.widthIcon;
            this.widthIcon = withIcon;

            text = text.replace("<opponent>", "<font color=" + game.opponentColor.text + ">");
            text = text.replace("</opponent>", "</font>");
            text = text.replace("<self>", "<font color=" + game.selfColor.text + ">");
            text = text.replace("</self>", "</font>");
            text = text.replace("<warning>", "<font color=red>");
            text = text.replace("</warning>", "</font>");
            this.container.style.display = "flex";
            this.icon.style.display = withIcon ? "default" : "none";
            this.span.innerHTML = text;
        }

        setPrevious() {
            this.setText(this.previousText, this.prevWidthIcon);
        }
    }

    class Table {
        constructor() {
            this.balls = [];
            let ballNum = 7 * 2 + 1 + 1;
            for (let i = 0; i < ballNum; i++) {
                let ball = this.createBall(this.getBallType(i));
                this.balls.push(ball);
            }
            this.stickAngle = 0;
            this.stickOffset = 0;
            this.createBall();
        }

        shotStart(target) {
            this.shotPowerStartX = target.x;
            this.shotPowerStartY = target.y;
        }

        aim(target) {
            this.stickAngle = Math.atan2(
                target.y - this.white.sprites.y,
                target.x - this.white.sprites.x
            );
        }

        moveStick(target) {
            let d = 0;
            if (window.mobileAndTabletcheck()) {
                d = target.y - this.shotPowerStartY;
                let max = 450;
                if (d < 0) {
                    this.shotPowerStartY = target.y;
                } else if (d > max) {
                    this.shotPowerStartY = target.y - max;
                }
                d = Math.max(0, Math.min(max, d));
                this.stickOffset = d * 120 / max;
            } else {
                let max = 120;
                let dx = this.shotPowerStartX - target.x;
                let dy = this.shotPowerStartY - target.y;
                d = Math.sqrt(dx * dx + dy * dy);
                let a = Math.atan2(dy, dx);
                d *= Math.cos(a - this.stickAngle);

                if (d < 0) {
                    this.shotPowerStartX = target.x;
                    this.shotPowerStartY = target.y;
                } else if (d > max) {
                    this.shotPowerStartX = target.x + Math.cos(a) * max;
                    this.shotPowerStartY = target.y + Math.sin(a) * max;
                }
                d = Math.max(0, Math.min(max, d));
                this.stickOffset = d;
            }
        }

        getBallType(i) {
            if (i < 7) {
                return 0;
            }
            if (i < 14) {
                return 1;
            }
            if (i == 14) {
                return BallTypes.white;
            }
            if (i == 15) {
                return BallTypes.puck;
            }
        }

        createBall(type) {
            return new Ball(type);
        }

        get puck() {
            return this.balls[15];
        }

        get white() {
            return this.balls[14];
        }

        isWhiteBall(ballIndex) {
            return ballIndex == 14;
        }

        isPuck(ballIndex) {
            return ballIndex > 14;
        }

        write(dataWriter) {
            this.balls.forEach(ball => ball.write(dataWriter));
            dataWriter.writeFloat32(this.stickAngle);
            dataWriter.writeInt16(this.stickOffset);
        }

        read(dataReader) {
            this.balls.forEach(ball => ball.read(dataReader));
            if (this.readStick) {
                this.stickAngle = dataReader.readFloat32();
                this.stickOffset = dataReader.readInt16();
            } else {
                dataReader.step(6);
            }
        }

        get size() {
            return this.balls.reduce((sum, ball) => sum + ball.size, 0) + 4 + 2;
        }

        show() {
            this.container.visible = true;
            this.table.visible = true;
            this.border.visible = true;
            this.centerSprite.visible = true;
            this.goalRight.visible = true;
            this.goalLeft.visible = true;
            this.goalTopRight.visible = true;
            this.goalTopLeft.visible = true;
            this.stick.visible = true;
        }

        showPanic() {
            this.container.visible = true;
            this.table.visible = false;
            this.border.visible = false;
            this.balls.forEach(b => b.sprites.visible = false);
            this.centerSprite.visible = false;
            this.goalRight.visible = false;
            this.goalLeft.visible = false;
            this.goalTopRight.visible = false;
            this.goalTopLeft.visible = false;
            this.stick.visible = false;
        }

        hide(){
            this.container.visible = false;
        }

        init(stage) {
            let container = new PIXI.Container();
            stage.addChild(container);

            let bg = new PIXI.Sprite(game.assetManager.getTexture("pockey_bg-01.png"));
            bg.position.set(-430,-240);
            container.addChild(bg);

            this.table = new PIXI.Sprite(game.assetManager.getTexture("table-default.png"));
            let color = game.tableColor[0];
            color = color << 8;
            color += game.tableColor[1];
            color = color << 8;
            color += game.tableColor[2];
            this.table.tint = color;
            container.addChild(this.table);
            this.table.position.set(49, 49);


            this.tableMatrix = new PIXI.filters.ColorMatrixFilter();
            this.table.filters = [this.tableMatrix];
            this.tableMatrix.brightness(game.tableBrightness);

            this.border = new PIXI.Sprite(game.assetManager.getTexture("table_border-01.png"));
            container.addChild(this.border);

            this.centerSprite = new PIXI.Sprite(game.assetManager.getTexture(game.getDecal(1).fileName));
            this.centerSprite.position.set(this.border.width/2 - this.centerSprite.width/2, this.border.height/2 - this.centerSprite.height/2);
            this.centerSprite.alpha = 0.4;
            this.centerSprite.tint = color;//0x22babc;
            container.addChild(this.centerSprite);

            this.puckIndicator = new PIXI.Sprite(game.assetManager.getTexture("puck-indicator.png"));
            this.puckIndicator.anchor.set(0.5, 0.5);
            container.addChild(this.puckIndicator);
            this.balls.forEach((ball, i) => {
                if (i < 14) {
                    ball.init(container, [{texture:"ball-shadow.png", offset:[1.5,1.5]},{texture:"ball-colorme.png"}, {texture:"ball-highlight.png", keep: true, offset:[1.5,1.5]}]);
                } else if (i == 14) {
                    ball.init(container, [{texture:"ball-shadow.png", offset:[1.5,1.5]},{texture:"ball-scratch.png"}]);
                } else {
                    ball.init(container, [{texture:"puck-icon.png", offset:[1.5,1.5]},{texture:"ball-puck.png"}, {texture:"ball-puck-02.png"}]);
                }
                ball.sprites.visible = false;
            });

            let color1 = game.getColor(1);
            let color2 = game.getColor(2);

            this.colorBalls(0, color1.value);
            this.colorBalls(1, color2.value);

            this.goalLeft = new PIXI.Sprite(game.assetManager.getTexture("goal-left.png"));
            this.goalLeft.position.set(0 -37, 0 + 220);
            container.addChild(this.goalLeft);
            this.goalLeft.tint = color1.value;

            let colorMatrix = new PIXI.filters.ColorMatrixFilter();
            this.goalLeft.filters = [colorMatrix];
            colorMatrix.saturate(0.0,false);

            this.goalTopLeft = new PIXI.Sprite(game.assetManager.getTexture("goal-top-left.png"));
            this.goalTopLeft.position.set(0 -39, 0 + 259);
            container.addChild(this.goalTopLeft);


            this.goalRight = new PIXI.Sprite(game.assetManager.getTexture("goal-right.png"));
            this.goalRight.position.set(this.border.width - 70, 0 + 218);
            container.addChild(this.goalRight);
            this.goalRight.tint = color2.value;

            let colorMatrix2 = new PIXI.filters.ColorMatrixFilter();
            this.goalRight.filters = [colorMatrix2];
            colorMatrix2.saturate(0.0,false);

            this.goalTopRight = new PIXI.Sprite(game.assetManager.getTexture("goal-top-right.png"));
            this.goalTopRight.position.set(this.border.width - 32, 0 + 259);
            container.addChild(this.goalTopRight);

            this.aimFeedback = new PIXI.Graphics();
            container.addChild(this.aimFeedback);

            this.stick = new PIXI.Sprite(game.assetManager.getTexture("stick_default.png"));
            this.stick.anchor.set(1, 0.5);
            this.stick.position.set(400, 400);

            this.touchStickContainer = new PIXI.Container();
            this.touchStickContainer.position.set(-80, 30);
            container.addChild(this.touchStickContainer);

            const loader = new PIXI.loaders.Loader();

            loader.add('powerColor', 'assets/textures/mobile/power-color.png')
                .add('powerBg', 'assets/textures/mobile/power-bg.png')
                .add('powerStick', 'assets/textures/mobile/power-stick.png')
                .add('droppuck', 'assets/textures/mobile/penalty-droppuck.png')
                .add('dropball', 'assets/textures/mobile/penalty-dropball.png');

            loader.load((loader, resources) => {
                this.touchStickBG = new PIXI.Sprite(resources.powerBg.texture);
                this.touchStickBG.x = -this.touchStickBG.width/2;
                this.touchStickContainer.addChild(this.touchStickBG);

                this.touchStickPower = new PIXI.Sprite(resources.powerColor.texture);
                this.touchStickPower.x = -this.touchStickPower.width/2;
                this.touchStickContainer.addChild(this.touchStickPower);

                this.touchStick = new PIXI.Sprite(resources.powerStick.texture);
                this.touchStick.x = -this.touchStick.width/2;
                this.touchStick.y = 76;

                this.touchStickContainer.addChild(this.touchStick);

                this.placeWhiteBallSprite = new PIXI.Sprite(resources.dropball.texture);
                container.addChild(this.placeWhiteBallSprite);
                this.placeWhiteBallSprite.anchor.set(0.4, 0.5);
                this.placeWhiteBallSprite.position.set(-80, 550);

                this.placePuckSprite = new PIXI.Sprite(resources.droppuck.texture);
                container.addChild(this.placePuckSprite);
                this.placePuckSprite.anchor.set(0.4, 0.5);
                this.placePuckSprite.position.set(-80, 550);

                this.placeWhiteBallSprite.interactive = true;
                this.placeWhiteBallSprite.on('pointerdown', (event) => {
                    event.stopPropagation();
                    game.touchPenalty = true;
                });

                this.placePuckSprite.interactive = true;
                this.placePuckSprite.on('pointerdown', (event) => {
                    event.stopPropagation();
                    game.touchPenalty = true;
                });
            });
            container.addChild(this.stick);

            if (!window.mobileAndTabletcheck()) {
                this.touchStickContainer.visible = false;
            }

            this.penaltyFeedback = new PIXI.Graphics();
            container.addChild(this.penaltyFeedback);

            this.tip = new Tip(container);
            this.container = container;
            this.hide();

            this.onResize();
        }

        updatePenaltyFeedback() {
            this.penaltyFeedback.visible = this.penaltyPos;
            this.touchStickContainer.visible = !this.penaltyPos && window.mobileAndTabletcheck() && game.shooter && !game.shotEnd && this.state == MatchStates.aim;
            if (this.placeWhiteBallSprite)
                this.placeWhiteBallSprite.visible = this.penaltyPos && this.state == MatchStates.penalty && window.mobileAndTabletcheck() && game.shooter;
            if (this.placePuckSprite)
                this.placePuckSprite.visible = this.penaltyPos && this.state == MatchStates.puckPenalty && window.mobileAndTabletcheck() && game.shooter;

            if (!this.penaltyFeedback.visible)
                return;

            let r = this.state == MatchStates.penalty ? this.white.r : this.puck.r;
            this.penaltyFeedback.clear();
            let lineWidth = 4;
            this.penaltyFeedback.lineStyle(lineWidth, 0xffffff, 0.7);
            this.penaltyFeedback.drawCircle(0, 0, r - lineWidth / 2);

            let x = lerp(this.penaltyFeedback.position.x, this.penaltyPos.x, Config.interpolationRate);
            let y = lerp(this.penaltyFeedback.position.y, this.penaltyPos.y, Config.interpolationRate);
            this.penaltyFeedback.position.set(x, y);
        }

        findHitBall() {
            let dist = Number.POSITIVE_INFINITY;
            let p;
            let b;
            let white = this.white.position;
            let index = 0;
            this.balls.forEach((ball,i) => {
                if (ball.white || !ball.sprites.visible) {
                    return;
                }

                let s = circleDirIntersect(white, this.stick.rotation, ball.position, this.white.r + ball.r);
                if (s) {
                    let dx = s.x - white.x;
                    let dy = s.y - white.y;
                    let d = Math.sqrt(dx * dx + dy * dy);
                    if (d < dist) {
                        dist = d;
                        p = s;
                        b = ball;
                        index = i;
                    }
                }
            });

            if (!p) {
                return;
            }

            return { newPosition: p, ball: b, index: index };
        }

        findHitWall() {
            let xMin = 72 + 16;
            let xMax = 1043 - 16;
            let yMin = 72 + 16;
            let yMax = 559 - 16;

            let dirX = Math.cos(this.stick.rotation);
            let dirY = Math.sin(this.stick.rotation);

            let white = this.white.position;
            let lambda = Number.POSITIVE_INFINITY;
            let l;
            if (white.x > xMin) {
                l = (xMin - white.x) / dirX;
                if (l > 0) {
                    lambda = Math.min(l, lambda);
                }
            }
            if (white.x < xMax) {
                l = (xMax - white.x) / dirX;
                if (l > 0) {
                    lambda = Math.min(l, lambda);
                }
            }
            if (white.y > yMin) {
                l = (yMin - white.y) / dirY;
                if (l > 0) {
                    lambda = Math.min(l, lambda);
                }
            }
            if (white.y < yMax) {
                l = (yMax - white.y) / dirY;
                if (l > 0) {
                    lambda = Math.min(l, lambda);
                }
            }

            return { x: white.x + lambda * dirX, y: white.y + lambda * dirY };
        }

        drawDirections(hitBall) {
            let p = hitBall.newPosition;
            let b = hitBall.ball.position;

            let white = this.white.position;

            let dir1 = { x: b.x - p.x, y: b.y - p.y };
            let angle1 = Math.atan2(dir1.y, dir1.x);
            let dir2 = { x: white.x - p.x, y: white.y - p.y };
            let angle2 = Math.atan2(dir2.y, dir2.x);
            let angle = angle1 + Math.sign(angle1 - angle2) * Math.PI / 2;

            //	let length = -Math.cos(angle - angle2) * 80;
            //	length += Math.sign(length) * 16;
            //this.aimFeedback.moveTo(p.x + Math.sign(length) * 16 * Math.cos(angle), p.y + Math.sign(length) * 16 * Math.sin(angle));
            //this.aimFeedback.lineTo(p.x + length * Math.cos(angle), p.y + length * Math.sin(angle));

            this.aimFeedback.moveTo(p.x + 16 * Math.cos(angle1), p.y + 16 * Math.sin(angle1));
            let length2 = -Math.cos(angle1 - angle2) * 80 + 16;
            this.aimFeedback.lineTo(p.x + length2 * Math.cos(angle1), p.y + length2 * Math.sin(angle1));
        }

        drawTarget(p, invalid) {
            let white = this.white.position;

            let dir2 = { x: white.x - p.x, y: white.y - p.y };
            let angle2 = Math.atan2(dir2.y, dir2.x);

            let lineWidth = 4;
            this.aimFeedback.lineStyle(lineWidth, 0xffffff, 0.7);
            this.aimFeedback.moveTo(white.x - 16 * Math.cos(angle2), white.y - 16 * Math.sin(angle2));
            this.aimFeedback.lineTo(p.x + 16 * Math.cos(angle2), p.y + 16 * Math.sin(angle2));
            this.aimFeedback.drawCircle(p.x, p.y, 16 - lineWidth / 2);

            if (invalid) {
                let r = 16 - lineWidth;
                this.aimFeedback.moveTo(p.x + r * Math.cos(Math.PI / 4),			p.y + r * Math.sin(Math.PI / 4));
                this.aimFeedback.lineTo(p.x + r * Math.cos(Math.PI + Math.PI / 4), 	p.y + r * Math.sin(Math.PI + Math.PI / 4));

                this.aimFeedback.moveTo(p.x + lineWidth / 2 * Math.cos(-Math.PI / 4), 			p.y + lineWidth / 2 * Math.sin(-Math.PI / 4));
                this.aimFeedback.lineTo(p.x + r * Math.cos(-Math.PI / 4), 			p.y + r * Math.sin(-Math.PI / 4));

                this.aimFeedback.moveTo(p.x + lineWidth / 2* Math.cos(Math.PI - Math.PI / 4), 	p.y + lineWidth / 2 * Math.sin(Math.PI - Math.PI / 4));
                this.aimFeedback.lineTo(p.x + r * Math.cos(Math.PI - Math.PI / 4), 	p.y + r * Math.sin(Math.PI - Math.PI / 4));
            }
        }

        validHit(ballIndex) {
            if (game.shooterIndex == 0) {
                return ballIndex >= 7;
            } else if (game.shooterIndex == 1) {
                return (ballIndex < 7 || ballIndex >= 14);
            }
        }

        updateAimFeedback() {
            this.aimFeedback.visible = this.puckIndicator.visible = this.state == MatchStates.aim && !this.shotEnd;
            if (!this.aimFeedback.visible)
                return;

            this.puckIndicator.position.copy(this.puck.position);
            let targetX = game.shooterIndex ? 0 : 1016;
            let targetY = 530 / 2;
            this.puckIndicator.rotation = Math.atan2(targetY - this.puckIndicator.y, targetX - this.puckIndicator.x);

            this.aimFeedback.clear();

            let hitBall = this.findHitBall();
            if (hitBall) {
                if (this.validHit(hitBall.index)) {
                    this.aimFeedback.tint = 0xffffff;
                    this.drawTarget(hitBall.newPosition);
                    this.drawDirections(hitBall);
                    this.setWrongTarget(false);
                } else {
                    this.aimFeedback.tint = 0xf33256;
                    this.drawTarget(hitBall.newPosition, true);
                    this.setWrongTarget(true);
                }
                this.setPuckTarget(hitBall.ball.puck);
            } else {
                this.aimFeedback.tint = 0xffffff;
                let hitWall = this.findHitWall();
                this.drawTarget(hitWall);
                this.setWrongTarget(false);
                this.setPuckTarget(false);
            }
        }

        setPuckTarget(puck) {
            if (!game.shooter) {
                return;
            }

            if (!this.puckTarget && puck) {
                let opponentNickname = game.opponent.userName;
                this.tip.setText("SHOOT THE PUCK INTO <opponent>" + opponentNickname + "'s GOAL!</opponent>");
            } else if (this.puckTarget && !puck) {
                this.tip.setPrevious();
            }
            this.puckTarget = puck;
        }


        setWrongTarget(wrong) {
            if (!game.shooter) {
                return;
            }

            if (!this.wrongTarget && wrong) {
                this.tip.setText("<warning>WARNING!</warning> HITTING YOUR <self>OWN BALL</self> FIRST IS A FOUL");
            } else if (this.wrongTarget && !wrong) {
                this.tip.setPrevious();
            }
            this.wrongTarget = wrong;
        }

        updateStick() {
            if (this.state == MatchStates.aim) {
                this.stick.position.set(game.table.white.x, game.table.white.y);

                while (this.stickAngle - this.stick.rotation > Math.PI) {
                    this.stickAngle -= Math.PI * 2;
                }
                while (this.stickAngle - this.stick.rotation < -Math.PI) {
                    this.stickAngle += Math.PI * 2;
                }
                this.stick.rotation = lerp(this.stick.rotation, this.stickAngle, Config.interpolationRate);
                if (window.mobileAndTabletcheck() && game.shooter) {
                    let newPos = 76 + this.stickOffset * 450 / 120;
                    this.touchStick.y = lerp(this.touchStick.y, newPos, Config.interpolationRate);

                    // green = 0, yellow = 25%, orange = 50%, red = 100%
                    let q = this.stickOffset / 120;
                    if (0 <= q && q < 0.25) {
                        this.touchStickPower.tint = rgbToHex(255 * q / 0.25, 255, 0);
                    } else if (0.25 <= q) {
                        this.touchStickPower.tint = rgbToHex(255, 255 * (1 - (q - 0.25) / 0.75), 0);
                    }
                }
            }
            this.stick.pivot.x = lerp(this.stick.pivot.x, this.stickOffset, Config.interpolationRate);
        }

        onResize() {
            if (window.mobileAndTabletcheck()) {
                let padding = 30;
                this.scale = Math.min((game.viewport.width - padding * 2) / 1112,
                    (game.viewport.height) / 626);
                this.container.scale.set(this.scale, this.scale);
                this.container.position.set(-1112 * this.scale / 2 + padding, -626 * this.scale / 2);
            } else {
                this.scale = Math.max(game.viewport.width / 1920, game.viewport.height / 1080);
                this.container.scale.set(this.scale, this.scale);
                this.container.position.set(-1112 * this.scale / 2, -626 * this.scale / 2);
            }
            this.tip.onResize();
        }

        update() {
            this.balls.forEach((ball, i) => {
                ball.update();
                //if (ball.puck) {
                //	let x = ball.sprites[0].position.x;
                //	ball.sprite.visible = x > 72 - ball.r && x < 1043 + ball.r;
                //}
            });
            this.updateStick();
            this.updateAimFeedback();
            this.updatePenaltyFeedback();
        }

        onBall(ballIndex) {
            let ball = this.balls[ballIndex];
            ball.pot = Date.now();
        }

        resetSprites() {
            this.balls.forEach(b =>b.reset());
        }

        colorBalls(playerIndex, color) {
            this.balls.forEach((b,i) => {
                if ((playerIndex == 0 && i < 7) || (playerIndex == 1 && i < 14 && i >= 7)) {
                    b.sprites.children.forEach(s=> {
                            if (!s.keepColor) {
                                s.tint = color
                            }
                        }
                    );
                }
            })
        }
    }

    class Screen {
        constructor (container) {
            this.container = container;
            this.shown = false;
        }

        show () {
            this.container.style.display = "flex";
            this.shown = true;
        }

        hide () {
            this.container.style.display = "none";
            this.shown = false;
        }

    }

    class MatchStateScreen extends Screen {
        constructor(container) {
            super(container)
            this.stateText = document.getElementById('matchstatetext');
            this.stateText2 = document.getElementById('matchstatetext2');
            this.opponent = document.getElementById('opponent');
            this.endMatchContainer = document.getElementById('endmatch');
            this.rematchButton = document.getElementById('rematch');
            this.stateTextContainer = document.getElementById('matchstatetextcontainer');
            this.roundComplete = document.getElementById("roundcomplete");
        }

        rematchRequested() {
            this.setStateText("Rematch requested","Waiting for opponent...");
            this.opponent.style.display = "none";
            this.endMatchContainer.style.display = "none";
            this.roundComplete.style.display = "none";
        }

        rematch() {
            this.setStateText("Revenga!", "Starting rematch...");
            this.refreshOpponent();
            this.opponent.style.display = "flex";
            $('#matchstatescreen').delay(3000).fadeOut(400, () => $('#matchdisplayscreen').fadeIn(400));
        }

        refreshOpponent() {
            let win = this.invite ? 0 : game.playerInfos[game.selfIndex].getScoreChange(game.playerInfos[this.opponentIndex].rank, true);
            let lose = this.invite ? 0 : game.playerInfos[game.selfIndex].getScoreChange(game.playerInfos[this.opponentIndex].rank, false);
            let nickname = document.getElementById('opponentname');
            nickname.innerHTML = censore(game.playerInfos[this.opponentIndex].userName,game.regexp);
            nickname.style.color = game.getColor(game.playerInfos[this.opponentIndex].color).text;
            let rank = document.getElementById('opponentrank');
            rank.innerHTML = RankType[game.playerInfos[this.opponentIndex].rank].nickname;
            rank.color = getRankColor(game.playerInfos[this.opponentIndex].rank);

            $("#opponentrankimg").attr('src','assets/ranks/color/rank-tier'+game.playerInfos[this.opponentIndex].rank+'.svg');

            $("#opponentavatarimg").attr('src','assets/avatars/'+game.getAvatar(game.playerInfos[this.opponentIndex].avatar).fileName);
            document.getElementById('opponentscore').innerHTML = '(' + game.playerInfos[this.opponentIndex].score + ')';
            // if (this.invite) {
            //     this.opponent.innerHTML += '<div>Friendly match';
            // } else {
            document.getElementById('opponentwin').innerHTML = win;
            document.getElementById('opponentlose').innerHTML = lose;
            // }
        }

        searchMatch() {
            this.setStateText("Searching for opponent");
            game.chatSystem.clearChat();
            game.chatSystem.addSystemMessage("Searching for new opponent..");
            game.startSearchAnimation();
            this.endMatchContainer.style.display = "none";
            this.roundComplete.style.display = "none";
        }

        startMatch(opponentIndex, invite) {
            this.setStateText("Opponent found!", "Starting match...");
            this.opponentIndex = opponentIndex;
            this.invite = invite
            this.refreshOpponent();
            this.opponent.style.display = "flex";
            $('#matchstatescreen').delay(4000).fadeOut(400, () => $('#matchdisplayscreen').fadeIn(400));
        }

        endRound(winnerIndex, end, disconnect) {
            aiptag.cmd.display.push(function() { aipDisplayTag.refresh('pockey-io_300x250'); })

            game.playerInfos.forEach((playerInfo, i) => {
                document.getElementById('endavatar' + i).src = 'assets/avatars/' + game.getAvatar(playerInfo.avatar).fileName;
                document.getElementById('endname' + i).innerHTML = censore(playerInfo.userName, game.regexp);
                document.getElementById('endname' + i).style.color= game.getColor(playerInfo.color).text;
                document.getElementById('endrank' + i).innerHTML = RankType[playerInfo.rank].nickname;
                //document.getElementById('player1rankscore').innerHTML = game.playerInfos[0].score;
                document.getElementById('endrankimg' + i).src = 'assets/ranks/color/rank-tier' + playerInfo.rank + '.svg';
                if (!disconnect) {
                    document.getElementById('endwinnertext' + i).innerHTML = i == winnerIndex ? "Winner!" : "";
                } else if (i != winnerIndex) {
                    document.getElementById('endwinnertext' + i).innerHTML = "disconnected";
                } else {
                    document.getElementById('endwinnertext' + i).innerHTML = "";
                }
                game.playerStates.forEach((p,i) => {
                    document.getElementById("streak" + i).innerHTML = p.maxStreak;
                    document.getElementById("trick" + i).innerHTML = p.maxTrickshot;
                    document.getElementById("fouls" + i).innerHTML = p.fouls;
                    document.getElementById("acc" + i).innerHTML = p.accuracy +"%";
                })
            });
            this.roundComplete.style.display = "flex";

            this.endMatchContainer.style.display = "flex";
            this.opponent.style.display = "none";
            this.stateTextContainer.style.display = "none";

            let roundNum = game.playerStates[0].score + game.playerStates[1].score;
            if (roundNum == 0)
                roundNum = 1;
            document.getElementById('endroundcounter').style.backgroundImage = "url('assets/matchscreenicons/vsflag-" + roundNum + ".svg')";

            document.getElementById('matchdisplayscreen').style.display = "none";
            if (end && !disconnect) {
                document.getElementById('returntxt').innerHTML = game.selfIndex == winnerIndex ? "You have won!" : "Your opponent has won!";
                document.getElementById('endmatchbtns').style.display = "flex";
                document.getElementById('rematch').style.display = "flex";
                this.roundComplete.innerHTML = "MATCH COMPLETE";
                $('#matchstatescreen').fadeIn(400);
            } else if (disconnect) {
                this.roundComplete.innerHTML = "MATCH COMPLETE";
                document.getElementById('returntxt').innerHTML = "Your opponent has left the game!";
                document.getElementById('endmatchbtns').style.display = "flex";
                $('#matchstatescreen').fadeIn(400);
                document.getElementById('rematch').style.display = "none";
            } else {
                document.getElementById('returntxt').innerHTML = "New round will begin shortly..."
                document.getElementById('returntxt').style.display = "flex";
                document.getElementById('endmatchbtns').style.display = "none";
                this.roundComplete.innerHTML = "ROUND COMPLETE";
                $('#matchstatescreen').fadeIn(400).delay(8500).fadeOut(400, () => $('#matchdisplayscreen').fadeIn(400));
            }
            // if (winnerIndex == game.selfIndex) {
            //     this.setStateText("You have won the round! New round will begin shortly.");
            // } else {
            //     this.setStateText(winnerInfo.userName +" has won the round! New round will begin shortly.");
            // }


        }

        endMatch(winnerIndex, disconnected) {
            this.endRound(winnerIndex, true, disconnected);
            return;

            let winnerInfo = game.playerInfos[winnerIndex];

            this.opponent.style.display = "none";
            if (winnerIndex == game.selfIndex) {
                if (disconnected) {
                    this.setStateText("Opponent has left!");
                } else {
                    this.setStateText("You have won the game!");
                }
            } else {
                this.setStateText(winnerInfo.userName +" has won the game!");
            }
            if (disconnected) {
                this.rematchButton.style.display = "none";
            } else {
                this.rematchButton.style.display = "flex";
            }
            this.endMatchContainer.style.display = "flex";
        }

        setStateText(text, text2) {
            this.stateTextContainer.style.display = "flex";
            this.stateText.innerHTML = text;
            if (text2) {
                this.stateText2.innerHTML = text2;
                this.stateText2.style.display = "flex";
            } else {
                this.stateText2.style.display = "none";
            }
        }
    }

    class MatchDisplayScreen extends Screen {
        constructor(container) {
            super(container)
        }

        setClock(time, player) {
            if (time > 0) {
                document.getElementById('clock0').style.display = "flex";
                document.getElementById('clock1').style.display = "flex";
                document.getElementById('clock' + (1 - player)).style.visibility = "hidden";
                document.getElementById('clock' + player).style.visibility = "visible";

                if (time < 10) {
                    document.getElementById("clock" + player).innerHTML = "0:0" + time;
                } else {
                    document.getElementById("clock" + player).innerHTML = "0:" + time;
                }
                if (time <= 5) {
                    document.getElementById("clock" + player).style.color = "red";
                }
            } else {
                document.getElementById('clock0').style.visibility = "hidden";
                document.getElementById('clock1').style.visibility = "hidden";
                document.getElementById('clock0').style.color = "white";
                document.getElementById('clock1').style.color = "white";
            }
        }

        rematch() {
        }

        searchMatch() {
            this.container.style.display = "none";
        }


        startMatch(player1Info, player2Info) {
            this.refreshPlayerInfos();
            $('#matchdisplayscreen').delay(3000).fadeIn(400);
        }

        endRound() {
        }


        refreshPlayerInfos() {
            document.getElementById('player1username').innerHTML = censore(game.playerInfos[0].userName, game.regexp);
            document.getElementById('player2username').innerHTML = censore(game.playerInfos[1].userName, game.regexp);
            document.getElementById('player1rankscore').innerHTML = game.playerInfos[0].score;
            document.getElementById('player2rankscore').innerHTML = game.playerInfos[1].score;

            $("#player1rankimg").attr('src','assets/ranks/shadowcolor/rank-tier'+game.playerInfos[0].rank+'.svg');
            $("#player2rankimg").attr('src','assets/ranks/shadowcolor/rank-tier'+game.playerInfos[1].rank+'.svg');

            $("#player1avatarimg").attr('src','assets/avatars/'+game.getAvatar(game.playerInfos[0].avatar).fileName);
            $("#player2avatarimg").attr('src','assets/avatars/'+game.getAvatar(game.playerInfos[1].avatar).fileName);

        }

    }

    class MatchDisplay {

        constructor(statecontainer) {
            this.matchStateScreen = new MatchStateScreen(document.getElementById("matchstatescreen"))
            this.matchDisplayScreen = new MatchDisplayScreen(document.getElementById("matchdisplayscreen"));
        }

        rematchRequested() {
            this.matchStateScreen.rematchRequested();
        }

        searchMatch() {
            this.matchDisplayScreen.searchMatch();
            this.matchStateScreen.searchMatch();
        }

        rematch() {
            this.matchStateScreen.rematch();
            this.matchDisplayScreen.rematch();
        }

        startMatch(invite) {
            let opponentIndex = 1 - game.selfIndex;
            this.matchStateScreen.startMatch(opponentIndex, invite);
            this.matchDisplayScreen.startMatch();
            game.table.resetSprites();
        }

        endRound(winnerIndex) {
            this.matchDisplayScreen.endRound();


            let endMatch = game.playerStates[winnerIndex].score >= 2;
            if (endMatch) {
                this.matchStateScreen.endMatch(winnerIndex);
            } else {
                this.matchStateScreen.endRound(winnerIndex);
            }
        }

        refreshPlayerInfos() {
            this.matchDisplayScreen.refreshPlayerInfos();
        }

        opponentDisconnected() {
            this.matchStateScreen.endMatch(game.selfIndex, true);
        }

        setStateText(text) {
            this.matchStateScreen.setStateText(text);
        }

        show() {
            this.matchStateScreen.show();
        }

        hide() {
            this.matchStateScreen.hide();
            this.matchDisplayScreen.hide();
        }
    }

    class Inventory {
        constructor() {

            this.inventoryList = document.getElementById("inventorylist");
            this.selectedItemName = document.getElementById("selecteditemname");
            this.selectedItemType = document.getElementById("selecteditemtype");
            this.selectedItemImg = document.getElementById("selecteditemimg");
            this.selectedItemImageElem = document.getElementById("selecteditemimage");
            this.inventoryPage = 0;
            this.starCoins = document.getElementById("starcoins");
            this.inventoryItems = [];

            this.selectedItem = "";
            this.equipButton = document.getElementById("equip");
            this.equipButton.addEventListener("click", () => {
                if (this.selectedItem.item && this.selectedItem.item.itemGuid) {
                    game.portalsocket.emit("equipRequest", this.selectedItem.item.itemGuid);
                }
            });

            this.filters = InventoryFilter.Stick | InventoryFilter.Avatar| InventoryFilter.Decal | InventoryFilter.Goalie | InventoryFilter.Misc;

            this.cueFilter = document.getElementById("cuefilter");
            this.cueFilter.filter = InventoryFilter.Stick;
            this.avatarFilter = document.getElementById("avatarfilter");
            this.avatarFilter.filter = InventoryFilter.Avatar;
            this.decalFilter = document.getElementById("decalfilter");
            this.decalFilter.filter = InventoryFilter.Decal;
            this.goalieFilter = document.getElementById("goaliefilter");
            this.goalieFilter.filter = InventoryFilter.Goalie;
            this.miscFilter = document.getElementById("miscfilter");
            this.miscFilter.filter = InventoryFilter.Misc;

            this.filterButtons = [];
            this.filterButtons.push(this.cueFilter);
            this.filterButtons.push(this.avatarFilter);
            this.filterButtons.push(this.decalFilter);
            this.filterButtons.push(this.goalieFilter);
            this.filterButtons.push(this.miscFilter);

            this.filterButtons.forEach(elem => {
                elem.addEventListener('click', (e) => {
                    this.toggleFilter(elem.filter);
                })
            })

            this.init();
            this.setupFilterButtons();
            this.inventory = game.inventory;

            this.prevInventory = document.getElementById("previnventory");
            this.prevInventory.addEventListener("click", () => {
                this.prev();
                return false;
            });

            this.nextInventory = document.getElementById("nextinventory");
            this.nextInventory.addEventListener("click", () => {
                this.next();
                return false;
            });

        }

        init() {
            this.inventoryList.innerHTML ="";
            this.inventoryItems = [];

            for (let i = 0; i<9;++i) {
                let column = document.createElement('div');
                column.className = "inventorycolumn";
                for (let j = 0; j<3;++j) {
                    let item = document.createElement('div');
                    item.className = "itemcommon";
                    item.id = "item"+(i*9 + j);

                    column.appendChild(item);

                    let itemImg = document.createElement('img');
                    itemImg.className = "itemimg";
                    item.appendChild(itemImg);

                    let itemEquipped = document.createElement('div');
                    itemEquipped.className = "itemimg equippedimg";
                    item.appendChild(itemEquipped);


                    let equippedImg = document.createElement('img');
                    //equippedImg.className = "itemimg";
                    equippedImg.src = "assets/icon_checkmark.svg";
                    itemEquipped.appendChild(equippedImg);
                    itemEquipped.style.display = "none";

                    let inventoryItem = {};
                    inventoryItem.divElem = item;
                    inventoryItem.img = itemImg;
                    inventoryItem.itemEquipped = itemEquipped;

                    item.inventoryItem = item;
                    item.addEventListener("click", () => {
                        this.inventoryItemSelected(inventoryItem);
                    });

                    this.inventoryItems.push(inventoryItem);
                }
                this.inventoryList.appendChild(column);
            }
        }

        setupFilterButtons() {
            let filter = 1;
            this.filterButtons.forEach((elem) => {
                if (this.filters & filter) {
                    elem.className = "filteractive";
                    elem.innerHTML = elem.innerHTML.replace("+", "-");
                } else {
                    elem.className = "filter";
                    elem.innerHTML =  elem.innerHTML.replace("-", "+");
                }
                filter *= 2;
            })
        }

        applyFilter() {
            this.inventory = [];
            if (!game.inventory)
                return;

            this.setupFilterButtons();
            game.inventory.forEach((itemGuid) => {
                let item = game.items.find(it => it.itemGuid == itemGuid);
                if (this.filters & item.filter && !(item.type == "color")) {
                    this.inventory.push(item);
                }
            })
        }

        toggleFilter(filter) {
            this.filters ^= filter;
            this.inventoryPage = 0;
            this.setup();
        }

        setup() {
            if (!game.inventory)
                return;

            this.applyFilter();

            for (let i = 0; i < 27; ++i) {
                let index = this.inventoryPage*27 + i;
                if (this.inventory[index]) {
                    let item = this.inventory[index];
                    let info = this.getItemInfo(item)
                    this.inventoryItems[i].img.src = info.iconFilename;
                    this.inventoryItems[i].img.style.display ="flex";
                    if (info.equipped) {
                        this.inventoryItems[i].divElem.className = "itemequipped";
                        this.inventoryItems[i].itemEquipped.style.display = "flex";
                    } else {
                        this.inventoryItems[i].divElem.className = "item"+info.rarity;
                        this.inventoryItems[i].itemEquipped.style.display = "none";
                    }
                    this.inventoryItems[i].divElem.style.pointerEvents ="visible";
                    this.inventoryItems[i].item = this.inventory[index];
                    this.inventoryItems[i].divElem.style.opacity = 1;
                } else {
                    this.inventoryItems[i].img.src ="";
                    this.inventoryItems[i].img.style.display ="none";
                    this.inventoryItems[i].divElem.style.pointerEvents ="none";
                    this.inventoryItems[i].divElem.style.opacity = 0.5;
                    this.inventoryItems[i].divElem.className = "itemcommon";
                    this.inventoryItems[i].itemEquipped.style.display = "none";
                    this.inventoryItems[i].item = null;
                }
            }

            this.starCoins.innerHTML = game.coins;
            this.setupPaginator();
        }


        getItemInfo(item) {
            let column = {};
            column.iconFilename = "assets/itemicon_stick-ph.png";
            column.equipped = false;
            column.rarity = getRarityName(item.rarity);
            column.rarityColor = getRarityColor(item.rarity);
            if (item.type == "avatar") {
                if (game.self.playerInfo.avatar == item.id) {
                    column.equipped = true;
                }
                column.iconFilename = "assets/avatars/"+item.fileName;
            } else if (item.type == "color") {
                if (game.self.playerInfo.color == item.id) {
                    column.equipped = true;
                }
            } else if (item.type == "stick") {
                if (game.self.playerInfo.stick == item.id) {
                    column.equipped = true;
                }
                column.iconFilename = "assets/itemicons/"+item.fileName;
            } else if (item.type == "decal") {
                if (game.self.playerInfo.decal == item.id) {
                    column.equipped = true;
                }
                column.iconFilename = "assets/itemdecal.png";
            } else if (item.type == "felt") {
                if (game.self.playerInfo.felt == item.id) {
                    column.equipped = true;
                }
                column.iconFilename = "assets/itemicons/felt"+item.id+".png";
            }

            return column;
        }



        inventoryItemSelected(inventoryItem) {
            if (this.selectedItem && this.selectedItem.item) {
                let prevInfo = this.getItemInfo(this.selectedItem.item);
                if (!prevInfo.equipped) {
                    this.selectedItem.divElem.className = "item" + prevInfo.rarity;
                }
            }

            this.selectedItem = inventoryItem;
            this.selectedItem.divElem.className = "itemequipped";
            if (inventoryItem.item) {
                let info = this.getItemInfo(inventoryItem.item);
                this.selectedItemImageElem.className = "item" + info.rarity;
                this.selectedItemName.innerHTML = inventoryItem.item.itemName;
                this.selectedItemType.innerHTML = info.rarity + " " +inventoryItem.item.type;
                this.selectedItemType.style.color = info.rarityColor;
                this.selectedItemImg.src = info.iconFilename;
                if (info.equipped) {
                    this.equipButton.className = "";
                    this.equipButton.innerHTML = "Equipped"
                } else {
                    this.equipButton.className = "btn";
                    this.equipButton.innerHTML = "Equip";
                }
            }
        }


        prev() {
            let pages = Math.floor(this.inventory.length / 28) + 1;
            if (pages > 1 && this.inventoryPage > 0) {
                this.inventoryPage = (this.inventoryPage - 1)  % pages;
                this.setup();
                this.setupPaginator();
            }
        }

        next() {
            let pages = Math.floor(this.inventory.length / 28) + 1;
            if (pages > 1 && this.inventoryPage < pages - 1) {
                this.inventoryPage = (this.inventoryPage + 1)  % pages;
                this.setup();
                this.setupPaginator();
            }
        }

        setupPaginator() {
            let pages = Math.floor(this.inventory.length / 28) + 1;
            if (this.inventoryPage == 0) {
                this.prevInventory.style.opacity = 0.5;
                this.prevInventory.style.pointerEvents = "none";
            } else {
                this.prevInventory.style.opacity = 1;
                this.prevInventory.style.pointerEvents = "visible";
            }

            if (this.inventoryPage == pages - 1) {
                this.nextInventory.style.opacity = 0.5;
                this.nextInventory.style.pointerEvents = "none";
            } else {
                this.nextInventory.style.opacity = 1;
                this.nextInventory.style.pointerEvents = "visible";
            }

        }
    }


    class Notificator {
        constructor() {
            this.notificationDialog = document.getElementById("notification")
            this.receivedItemImage = document.getElementById("receiveditemimage");
            this.receivedItemImg = document.getElementById("receiveditemimg");
            this.receivedItemName = document.getElementById("receiveditemname");
            this.receivedItemMsg = document.getElementById("receiveditemmsg");
            this.notifications = [];

            document.getElementById("receiveditemclose").addEventListener("click", () => {
                this.clearCurrentNotification();
            })
        }

        update() {
            if (this.notifications.length) {
                let notification = this.notifications[0];
                if (notification.state == "new") {
                    this.showNotification(notification);
                } else if (notification.state == "show") {
                    if (notification.delay > 0) {
                        notification.delay -= Config.clientFrameTime;
                    } else {
                        notification.state = "fading";
                        $("#notification").fadeOut(2000, () => {
                            this.clearCurrentNotification();
                        });
                    }
                }
            }
        }

        clearCurrentNotification() {
            if (this.notifications.length) {
                $("#notification").stop(true, true);
                this.notificationDialog.style.display = "none";
                this.notifications.shift();
            }
        }

        showNotification(notification) {
            if (notification.note == "item") {
                let itemInfo = game.gui.inventoryScreen.getItemInfo(notification.item);
                if (itemInfo) {
                    game.soundEngine.playSound("unlock");

                    this.receivedItemName.innerHTML = notification.item.itemName;
                    switch (notification.item.type) {
                        case "stick": this.receivedItemMsg.innerHTML = "NEW CUE UNLOCKED!"; break;
                        case "avatar": this.receivedItemMsg.innerHTML = "NEW AVATAR UNLOCKED!"; break;
                        case "decal": this.receivedItemMsg.innerHTML = "NEW DECAL UNLOCKED!"; break;
                        case "felt": this.receivedItemMsg.innerHTML = "NEW FELT COLOR UNLOCKED!"; break;
                        case "stick": this.receivedItemMsg.innerHTML = "NEW CUE UNLOCKED!"; break;
                        case "color": this.receivedItemMsg.innerHTML = "NEW COLOR UNLOCKED!"; break;
                        default: this.receivedItemMsg.innerHTML = "NEW ITEM UNLOCKED!"; break;
                    }
                    this.receivedItemImg.src = itemInfo.iconFilename;
                    this.receivedItemImage.className = "item"+itemInfo.rarity;
                    notification.state = "show";
                    notification.delay = 5000;
                    $("#notification").fadeIn("1000");
                }
            }
        }

        itemReceived(item) {
            this.notifications.push({note:"item", item:item, state:"new"});
        }

        coinsReceived(coins) {
            this.notifications.push({note:"item", coins:coins, state:"new"});
        }
    }

    class GUI {
        constructor (game) {
            this.matchDisplay = new MatchDisplay();
            this.settings = document.getElementById("settings");
            this.settingsVisible = false;



            if (readCookie("cookiesAccepted")) {
            }

            this.leftMenuItems = [];
            this.leftMenuItems.push({arrow: document.getElementById("playgamearrow"),
                item: document.getElementById("playgame"),
                highlight: document.getElementById("playgamehighlight")});
            this.leftMenuItems.push({arrow: document.getElementById("inventoryarrow"),
                item: document.getElementById("inventory"),
                highlight: document.getElementById("inventoryhighlight")});
            this.leftMenuItems.push({arrow: document.getElementById("invitearrow"),
                item: document.getElementById("invite"),
                highlight: document.getElementById("invitehighlight")});
            this.leftMenuItems.push({arrow: document.getElementById("allstarsarrow"),
                item: document.getElementById("allstars"),
                highlight: document.getElementById("allstarshighlight")});

            // $('.leftmenubutton').hover(
            // function(){
            //     $(this).css('color','white');
            // },
            // function(){
            //     $(this).css('color','#20d7e7');
            // });
            this.highscores = document.getElementById("highscores");
            this.inventory = document.getElementById("inventoryscreen");


            this.loginContainer = document.getElementById("logincontainer");
            this.howTo = document.getElementById("howto");
            this.invite = document.getElementById("invitescreen");
            this.main = document.getElementById("main");
            this.leftMenu = document.getElementById("leftmenu");
            this.verticalMain = document.getElementById("verticalMain");
            this.mainLeft = document.getElementById("mainleft");
            this.mainRight = document.getElementById("mainright");

            this.invitelink = document.getElementById("invitelink");
            this.invitebtn = document.getElementById("invitebtn");
            this.copybtn = document.getElementById("copybtn");
            this.copymsg = document.getElementById("copymsg");

            this.inventoryScreen = new Inventory();
            this.inventoryScreen.init();

            this.notificator = new Notificator();
        }

        setupInviteScreen(inviteId) {
            this.invitelink.innerHTML="https://pockey.io?i="+inviteId;
            this.invitelink.style.display = "flex";
            this.invitebtn.style.display = "none";
            this.copybtn.style.display = "flex";
            this.copymsg.style.display = "flex";
        }



        hidePrivacyContainer() {
            document.getElementById("privacycontainer").style.display = "none";
        }

        hideMainAll() {
            this.hidePrivacyContainer();
            this.main.style.display = 'none';
            this.leftMenu.style.display = 'none';
//        this.loginContainer.style.display = 'none';
//        this.highscores.style.display = 'none';
//        this.howTo.style.display = 'none';

            //document.getElementById("teamball").style.display = 'none';
            //document.getElementById("account").style.display = 'none';
        }

        hideMainScreen(){
            this.loginContainer.style.display = 'none';
            this.highscores.style.display = 'none';
            this.inventory.style.display = 'none';
            this.howTo.style.display = 'none';
            this.invite.style.display = 'none';

            //document.getElementById("teamball").style.display = 'none';
            //document.getElementById("account").style.display = 'none';
        }

        deselectLeftMenuItems() {
            this.leftMenuItems.forEach(i => {
                i.arrow.style.display = "none";
                i.highlight.style.visibility = "hidden";
                i.item.className = "leftmenubutton";
            });
        }


        selectLeftMenuItem(index) {
            this.deselectLeftMenuItems();
            this.leftMenuItems[index].arrow.style.display = "flex";
            this.leftMenuItems[index].highlight.style.visibility = "visible";
            this.leftMenuItems[index].item.className = "leftmenubuttonselected";
        }

        selectPlayGame() {
            this.selectLeftMenuItem(0);
            this.hideMainScreen();
            this.loginContainer.style.display = "flex";
            this.verticalMain.style.display = "flex";
            this.mainLeft.style.display = "flex";
            this.mainRight.style.display = "flex";
            this.howTo.style.display = 'flex';
        }

        selectInventory() {
            this.selectLeftMenuItem(1);
            this.hideMainScreen();
            this.inventory.style.display = "flex";
            this.verticalMain.style.display = "none";
            this.mainLeft.style.display = "none";
            this.mainRight.style.display = "none";
        }

        selectInvite() {
            this.selectLeftMenuItem(2);
            this.hideMainScreen();
            this.loginContainer.style.display = "flex";
            this.verticalMain.style.display = "flex";
            this.mainLeft.style.display = "flex";
            this.mainRight.style.display = "flex";
            this.invite.style.display = 'flex';
        }

        selectAllStars() {
            this.selectLeftMenuItem(3);
            this.hideMainScreen();
            this.highscores.style.display = "flex";
            this.verticalMain.style.display = "none";
            this.mainLeft.style.display = "none";
            this.mainRight.style.display = "none";
        }


        settingsShown() {
            return this.settingsVisible;
        }

        hideSettings() {
            this.settingsVisible = false;
            this.settings.style.display = "none";
        }

        showSettings() {
            this.settingsVisible = true;
            this.settings.style.display = "flex";
        }

        hideAllScreens() {
            this.screens.forEach(s => {
                s.hide();
            })
        }

        acceptCookies() {
            createCookie("cookiesAccepted");
        }

        showMatchDisplay() {
            this.matchDisplay.show();
        }

        update(self, game) {
        }
    }


    class Customizer {
        constructor() {
            this.prevColor = document.getElementById("prevcolor");
            this.nextColor = document.getElementById("nextcolor");
            this.color = document.getElementById("color");

            this.prevAvatar = document.getElementById("prevavatar");
            this.nextAvatar = document.getElementById("nextavatar");
            this.avatar = document.getElementById("playeravatar");

            this.avatarIndex = 0;
            this.colorIndex = 0;

            this.COLORS = [1,2];
            this.avatars = [0];

            this.prevColor.addEventListener("click", (e) => {
                this.colorIndex -= 1;
                if (this.colorIndex < 0) {
                    this.colorIndex = this.COLORS.length - 1;
                }
                game.self.playerInfo.color = this.COLORS[this.colorIndex];
                this.refreshColor();
                return false;
            });

            this.nextColor.addEventListener("click", (e) => {
                this.colorIndex = (this.colorIndex + 1) % this.COLORS.length;
                game.self.playerInfo.color = this.COLORS[this.colorIndex];
                this.refreshColor();
                return false;
            });

            this.prevAvatar.addEventListener("click", (e) => {
                this.avatarIndex -= 1;
                if (this.avatarIndex < 0) {
                    this.avatarIndex = this.avatars.length - 1;
                }
                game.self.playerInfo.avatar = this.avatars[this.avatarIndex];
                this.refreshAvatar();
                return false;
            });

            this.nextAvatar.addEventListener("click", (e) => {
                this.avatarIndex = (this.avatarIndex + 1) % this.avatars.length;
                game.self.playerInfo.avatar = this.avatars[this.avatarIndex];
                this.refreshAvatar();
                return false;
            });
        }

        refreshAvatar() {
            $('#'+this.avatar.id).attr('src','assets/avatars/'+game.getAvatar(this.avatars[this.avatarIndex]).fileName);
        }

        refreshColor() {
            this.color.style.backgroundColor = game.getColor(this.COLORS[this.colorIndex]).text;
        }

        refreshCustomizer() {
            this.refreshAvatar();
            this.refreshColor();
        }

        setupCustomizer() {
            this.COLORS = [];
            this.avatars = [];

            game.inventory.forEach(i => {
                let item = game.items.find(it => it.itemGuid == i);
                if (item) {
                    if (item.type == "color") {
                        this.COLORS.push(item.id);
                    } else if (item.type == "avatar") {
                        this.avatars.push(item.id);
                    }
                }
            })
        }

        playerInfoUpdated() {
            if (game.self.playerInfo && game.inventory && game.items) {
                this.setupCustomizer();
                this.avatarIndex = this.avatars.findIndex((a) => { return a == game.self.playerInfo.avatar});
                if (this.avatarIndex < 0) {
                    this.avatarIndex = 0;
                }
                this.colorIndex = this.COLORS.findIndex((c) => { return c == game.self.playerInfo.color} );
                if (this.colorIndex < 0) {
                    this.colorIndex = 0;
                }
                this.refreshCustomizer();
            }
        }
    }


    class MouseHandler {
        constructor(game) {
            this.mouseDown = false;
            this.rightMouseDown = false;
            this.lastRecievedPos = null;
            this.lastRecievedTime = 0;
            this.pos = new Coord(0, 0);
            this.wheeledDown = false;
            this.wheeledUp = false;
            this.game = game;

            game.viewport.addEventListener("mouseleave", (e) => {
                this.lastRecievedPos = null;
            });

            game.viewport.addEventListener("mousemove", (event) => {
                event.preventDefault();
                this.moveTarget(event.offsetX, event.offsetY);
            });

            game.viewport.addEventListener("touchmove", (event) => {
                if (game.table.state == MatchStates.penalty || game.table.state == MatchStates.puckPenalty) {
                    return;
                }
                let touch = event.changedTouches[0];
                if (touch) {
                    event.preventDefault();
                    this.moveTarget(touch.clientX, touch.clientY);
                }
            });

            game.viewport.addEventListener("touchend", (event) => {
                game.touchShoot = false;
            });

            game.viewport.addEventListener("click", (event) => {
            });

            game.viewport.addEventListener("contextmenu", (event) => {
                event.preventDefault();
            });

            game.viewport.addEventListener("mousedown", (event) => {
                event.preventDefault();
                if (event.buttons & 1) {
                    this.mouseDown = true;
                }
                if (event.buttons & 2) {
                    this.rightMouseDown = true;
                }

                var screenPos = new Coord(event.offsetX, event.offsetY);
            });

            game.viewport.addEventListener("mouseup", (event) => {
                if (!(event.buttons & 1)) {
                    this.mouseDown = false;
                }
                if (!(event.buttons & 2)) {
                    this.rightMouseDown = false;
                }
            });

            game.viewport.addEventListener("wheel", (event) => {
                this.wheeledDown = event.deltaY > 0.0;
                this.wheeledUp = event.deltaY < 0.0;
            });
        }

        moveTarget(x, y) {
            this.lastRecievedPos = new Coord(x * Config.canvasRes, y * Config.canvasRes);
            this.moved = true;
            this.lastRecievedTime = Date.now();
        }

        resetWheel() {
            this.wheeledDown = false;
            this.wheeledUp = false;
        }

        getData() {
            if (!this.lastRecievedPos || !this.moved) {
                return null;
            }

            return {
                pos: this.pos.copy(),
                down: this.mouseDown,
                rightDown: this.rightMouseDown
            };
        }

        screenToModel(s) {
            let x = s.x - game.viewport.width / 2 + game.table.scale * 1112 / 2;
            let y = s.y - game.viewport.height / 2 + game.table.scale * 626 / 2;
            return new Coord(x / game.table.scale, y / game.table.scale);
        }

        update() {
            if (!this.game.client_logged_in) {
                return;
            }

            if (this.lastRecievedPos) {
                this.pos = this.screenToModel(this.lastRecievedPos);
            }
        }
    }

    var MatchEventTypes = {
        NewMatch:1,
        HealthUpdate:2,
        ShooterIndex:3,
        BallEvent:4,
        ShotEvent:5,
        RoundEvent: 6,
        Rematch: 7,
        Message: 8,
        PlayerInfos: 9,
        BallHit: 10,
        WallHit: 11,
        Timer: 12,
        PuckEvent:13,
        Disconnect:14
    }

    class MatchEvent {
        constructor(eventType) {
            this.type = MatchEvent.type;
            this.eventType = eventType;
        }

        static read(dataReader) {
            this.eventType = dataReader.readUint8();
            let event = new MatchEvent(this.eventType);
            switch(this.eventType) {
                case MatchEventTypes.NewMatch: event.readNewMatch(dataReader); break;
                case MatchEventTypes.HealthUpdate: event.readHealthUpdate(dataReader); break;
                case MatchEventTypes.ShooterIndex: event.readShooterIndex(dataReader); break;
                case MatchEventTypes.BallEvent: event.readBallEvent(dataReader); break;
                case MatchEventTypes.ShotEvent: event.readShotEvent(dataReader); break;
                case MatchEventTypes.RoundEvent: event.readRoundEvent(dataReader); break;
                case MatchEventTypes.Rematch: event.readRematch(dataReader); break;
                case MatchEventTypes.Message: event.readMessage(dataReader); break;
                case MatchEventTypes.PlayerInfos: event.readPlayerInfos(dataReader); break;
                case MatchEventTypes.BallHit: event.readBallHit(dataReader); break;
                case MatchEventTypes.WallHit: event.readWallHit(dataReader); break;
                case MatchEventTypes.Timer: event.readTimer(dataReader); break;
                case MatchEventTypes.PuckEvent: event.readPuckEvent(dataReader); break;
                case MatchEventTypes.Disconnect: event.readDisconnect(dataReader); break;
            }
            return event;
        };

        write(dataWriter) {
            dataWriter.writeUint8(this.eventType);
            switch(this.eventType) {
                case MatchEventTypes.NewMatch: this.writeNewMatch(dataWriter); break;
                case MatchEventTypes.HealthUpdate: this.writeHealthUpdate(dataWriter); break;
                case MatchEventTypes.ShooterIndex: this.writeShooterIndex(dataWriter); break;
                case MatchEventTypes.BallEvent: this.writeBallEvent(dataWriter); break;
                case MatchEventTypes.ShotEvent: this.writeShotEvent(dataWriter); break;
                case MatchEventTypes.RoundEvent: this.writeRoundEvent(dataWriter); break;
                case MatchEventTypes.Rematch: this.writeRematch(dataWriter); break;
                case MatchEventTypes.Message: this.writeMessage(dataWriter); break;
                case MatchEventTypes.PlayerInfos: this.writePlayerInfos(dataWriter); break;
                case MatchEventTypes.BallHit: this.writeBallHit(dataWriter); break;
                case MatchEventTypes.WallHit: this.writeWallHit(dataWriter); break;
                case MatchEventTypes.Timer: this.writeTimer(dataWriter); break;
                case MatchEventTypes.PuckEvent: this.writePuckEvent(dataWriter); break;
                case MatchEventTypes.Disconnect: this.writeDisconnect(dataWriter); break;
            }
        };

        get size() {
            let size = 1;
            switch(this.eventType) {
                case MatchEventTypes.NewMatch: size += this.sizeNewMatch(); break;//column.playerInfo1.size + column.playerInfo2.size;
                case MatchEventTypes.HealthUpdate: size += this.sizeHealthUpdate(); break;
                case MatchEventTypes.ShooterIndex: size += this.sizeShooterIndex(); break;
                case MatchEventTypes.BallEvent: size += this.sizeBallEvent(); break;
                case MatchEventTypes.ShotEvent: size += this.sizeShotEvent(); break;
                case MatchEventTypes.RoundEvent: size += this.sizeRoundEvent(); break;
                case MatchEventTypes.Rematch: size += this.sizeRematch(); break;
                case MatchEventTypes.Message: size += this.sizeMessage(); break;
                case MatchEventTypes.PlayerInfos: size += this.sizePlayerInfos(); break;
                case MatchEventTypes.BallHit: size += this.sizeBallHit(); break;
                case MatchEventTypes.WallHit: size += this.sizeWallHit(); break;
                case MatchEventTypes.Timer: size += this.sizeTimer(); break;
                case MatchEventTypes.PuckEvent: size += this.sizePuckEvent(); break;
                case MatchEventTypes.Disconnect: size += this.sizeDisconnect(); break;
            }
            return size;
        }

        handle() {
            switch(this.eventType) {
                case MatchEventTypes.NewMatch: this.handleNewMatch(); break;
                case MatchEventTypes.HealthUpdate: this.handleHealthUpdate(); break;
                case MatchEventTypes.ShooterIndex: this.handleShooterIndex(); break;
                case MatchEventTypes.BallEvent: this.handleBallEvent(); break;
                case MatchEventTypes.ShotEvent: this.handleShotEvent(); break;
                case MatchEventTypes.RoundEvent: this.handleRoundEvent(); break;
                case MatchEventTypes.Rematch: this.handleRematch(); break;
                case MatchEventTypes.Message: this.handleMessage(); break;
                case MatchEventTypes.PlayerInfos: this.handlePlayerInfos(); break;
                case MatchEventTypes.BallHit: this.handleBallHit(); break;
                case MatchEventTypes.WallHit: this.handleWallHit(); break;
                case MatchEventTypes.Timer: this.handleTimer(); break;
                case MatchEventTypes.PuckEvent: this.handlePuckEvent(); break;
                case MatchEventTypes.Disconnect: this.handleDisconnect(); break;
            }
        }


        static NewMatch(playerInfo1, playerInfo2, invite) {
            let event = new MatchEvent(MatchEventTypes.NewMatch);
            event.playerInfo1 = playerInfo1;
            event.playerInfo2 = playerInfo2;
            event.invite = invite;
            return event;
        }

        sizeNewMatch() {
            return this.playerInfo1.size + this.playerInfo2.size + 1;
        }

        readNewMatch(dataReader) {
            this.playerInfo1 = new PlayerInfo();
            this.playerInfo1.read(dataReader);
            this.playerInfo2 = new PlayerInfo();
            this.playerInfo2.read(dataReader);
            this.invite = dataReader.readUint8();
        };

        writeNewMatch(dataWriter) {
            this.playerInfo1.write(dataWriter);
            this.playerInfo2.write(dataWriter);
            dataWriter.writeUint8(this.invite);
        }

        handleNewMatch() {
            game.ownerIndex = 0;
            game.playerInfos = [];
            game.playerInfos.push(this.playerInfo1);
            game.playerInfos.push(this.playerInfo2);

            game.selfIndex = this.playerInfo1.guid == game.self.playerInfo.guid ? 0 : 1;

            if (game.playerInfos[game.selfIndex].color == game.playerInfos[1-game.selfIndex].color) {
                let color = game.COLORS.find(c => c.id != game.playerInfos[1-game.selfIndex].color);
                if (color) {
                    game.playerInfos[1-game.selfIndex].color = color.id;
                }
            }
            game.table.centerSprite.texture = game.assetManager.getTexture(game.getDecal(this.playerInfo1.decal).fileName);

            game.playerStates = [];
            game.playerStates.push({hp:7, score: 0});
            game.playerStates.push({hp:7, score: 0});
            game.setScoreBars();
            game.setHpBars();
            game.gui.matchDisplay.startMatch(this.invite);
            game.recolorAll();
            game.soundEngine.playSound("start");
            game.stopSearchAnimation();
        }


        static HealthUpdate(player1hp, player2hp) {
            let event = new MatchEvent(MatchEventTypes.HealthUpdate);
            event.player1hp = player1hp;
            event.player2hp = player2hp;
            return event;
        }

        sizeHealthUpdate() {
            return 2;
        }

        readHealthUpdate(dataReader) {
            this.player1hp = dataReader.readUint8();
            this.player2hp = dataReader.readUint8();
        };

        writeHealthUpdate(dataWriter) {
            dataWriter.writeUint8(this.player1hp);
            dataWriter.writeUint8(this.player2hp);
        }

        handleHealthUpdate() {
            game.playerStates[0].hp = this.player1hp;
            game.playerStates[1].hp = this.player2hp;
            game.setHpBars();
        }


        static ShooterIndex(shooterIndex) {
            let event = new MatchEvent(MatchEventTypes.ShooterIndex);
            event.shooterIndex = shooterIndex;
            return event;
        }

        sizeShooterIndex() {
            return 1;
        }

        readShooterIndex(dataReader) {
            this.shooterIndex = dataReader.readInt8();
        };

        writeShooterIndex(dataWriter) {
            dataWriter.writeInt8(this.shooterIndex);
        }

        handleShooterIndex() {
            if (this.shooterIndex == 0) {
                game.changeStick(game.playerInfos[this.shooterIndex]);

                $("#player1avatar").removeClass("avatar");
                $("#player1avatar").addClass("avatarshoot");
                $("#player2avatar").removeClass("avatarshoot");
                $("#player2avatar").addClass("avatar");

            } else if (this.shooterIndex == 1) {
                game.changeStick(game.playerInfos[this.shooterIndex]);

                $("#player2avatar").removeClass("avatar");
                $("#player2avatar").addClass("avatarshoot");
                $("#player1avatar").removeClass("avatarshoot");
                $("#player1avatar").addClass("avatar");
            } else {
                $("#player1avatar").removeClass("avatarshoot");
                $("#player1avatar").addClass("avatar");
                $("#player2avatar").removeClass("avatarshoot");
                $("#player2avatar").addClass("avatar");
            }
            if (this.shooterIndex == game.selfIndex) {
                game.chatSystem.addSystemMessage("Your turn!");
                game.soundEngine.playSound("shooter");
            } else if (this.shooterIndex == (1 - game.selfIndex)) {
                game.chatSystem.addSystemMessage(game.playerInfos[this.shooterIndex].userName+"'s turn!");
            }
            game.shooterIndex = this.shooterIndex;
        };


        static BallEvent(ballIndex, v) {
            let event = new MatchEvent(MatchEventTypes.BallEvent);
            event.ballIndex = ballIndex;
            event.v = v / 10;
            return event;
        }

        sizeBallEvent() {
            return 2;
        }

        readBallEvent(dataReader) {
            this.ballIndex = dataReader.readUint8();
            this.v = dataReader.readUint8();
        };

        writeBallEvent(dataWriter) {
            dataWriter.writeUint8(this.ballIndex);
            dataWriter.writeUint8(this.v);
        }

        handleBallEvent() {
            game.table.onBall(this.ballIndex);
            game.soundEngine.playRandomSound("score",1,3).setVolume(Math.max(30, this.v * 0.8));
        }


        static ShotEvent(force) {
            let event = new MatchEvent(MatchEventTypes.ShotEvent);
            event.force = force;
            return event;
        }

        sizeShotEvent() {
            return 1;
        }

        readShotEvent(dataReader) {
            this.force = dataReader.readUint8();
        }

        writeShotEvent(dataWriter) {
            dataWriter.writeUint8(this.force);
        }

        handleShotEvent() {
            game.soundEngine.playSound("shot").setVolume(this.force);
        }


        static RoundEvent(winnerIndex, player1, player2) {
            let event = new MatchEvent(MatchEventTypes.RoundEvent);
            event.winnerIndex = winnerIndex;
            event.player1 = player1;
            event.player2 = player2;
            return event;
        }

        sizeRoundEvent() {
            return 11;
        }

        readRoundEvent(dataReader) {
            this.winnerIndex = dataReader.readUint8();
            this.player1Score = dataReader.readUint8();
            this.player1Fouls = dataReader.readUint8();
            this.player1MaxTrickshot = dataReader.readUint8();
            this.player1MaxStreak = dataReader.readUint8();
            this.player1Accuracy = dataReader.readUint8();

            this.player2Score = dataReader.readUint8();
            this.player2Fouls = dataReader.readUint8();
            this.player2MaxTrickshot = dataReader.readUint8();
            this.player2MaxStreak = dataReader.readUint8();
            this.player2Accuracy = dataReader.readUint8();
        }

        writeRoundEvent(dataWriter) {
            dataWriter.writeUint8(this.winnerIndex);
            dataWriter.writeUint8(this.player1.score);
            dataWriter.writeUint8(this.player1.fouls);
            dataWriter.writeUint8(this.player1.maxTrickshot);
            dataWriter.writeUint8(this.player1.maxStreak);
            dataWriter.writeUint8(this.player1.shots ? Math.round((this.player1.shotsScored/this.player1.shots)*100) : 0);

            dataWriter.writeUint8(this.player2.score);
            dataWriter.writeUint8(this.player2.fouls);
            dataWriter.writeUint8(this.player2.maxTrickshot);
            dataWriter.writeUint8(this.player2.maxStreak);
            dataWriter.writeUint8(this.player2.shots ? Math.round((this.player2.shotsScored/this.player2.shots)*100) : 0);
        }

        handleRoundEvent() {
            setTimeout(()=>{
                game.table.resetSprites();
                game.ownerIndex = (game.ownerIndex + 1) % 2;
                game.table.centerSprite.texture = game.assetManager.getTexture(game.getDecal(game.playerInfos[game.ownerIndex].decal).fileName);
            }, 3000);
            game.playerStates[0].score = this.player1Score;
            game.playerStates[0].fouls = this.player1Fouls;
            game.playerStates[0].maxTrickshot = this.player1MaxTrickshot;
            game.playerStates[0].maxStreak = this.player1MaxStreak;
            game.playerStates[0].accuracy = this.player1Accuracy;

            game.playerStates[1].score = this.player2Score;
            game.playerStates[1].fouls = this.player2Fouls;
            game.playerStates[1].maxTrickshot = this.player2MaxTrickshot;
            game.playerStates[1].maxStreak = this.player2MaxStreak;
            game.playerStates[1].accuracy = this.player2Accuracy;

            game.gui.matchDisplay.endRound(this.winnerIndex);
            game.setScoreBars();
        }


        static Rematch() {
            let event = new MatchEvent(MatchEventTypes.Rematch);
            return event;
        }

        sizeRematch() {
            return 0;
        }

        readRematch(dataReader) {
        }

        writeRematch(dataWriter) {
        }

        handleRematch() {
            game.playerStates[0].score = 0;
            game.playerStates[1].score = 0;
            game.playerStates[0].hp = 7;
            game.playerStates[1].hp = 7;
            game.gui.matchDisplay.rematch();
            game.setScoreBars();
            game.setHpBars();
            setTimeout(()=>{
                game.ownerIndex = (game.ownerIndex + 1) % 2;
                game.table.centerSprite.texture = game.assetManager.getTexture(game.getDecal(game.playerInfos[game.ownerIndex].decal).fileName);
            }, 3000);
            game.soundEngine.playSound("start");
        }


        static Message(playerIndex, message) {
            let event = new MatchEvent(MatchEventTypes.Message);
            event.playerIndex = playerIndex;
            event.message = message;
            return event;
        }

        sizeMessage() {
            return 1 + this.message.length*4 + 4;
        }

        readMessage(dataReader) {
            this.playerIndex = dataReader.readUint8();
            this.message = dataReader.readString();
        }

        writeMessage(dataWriter) {
            dataWriter.writeUint8(this.playerIndex);
            dataWriter.writeString(this.message);
        }

        handleMessage() {
            if (this.playerIndex <= 1) {
                game.chatSystem.addMessage(this.playerIndex, this.message);
            } else if (this.playerIndex == 2) {
                game.chatSystem.addSystemMessage(this.message);
            }
        }


        static PlayerInfos(playerInfo1, playerInfo2) {
            let event = new MatchEvent(MatchEventTypes.PlayerInfos);
            event.playerInfo1 = playerInfo1;
            event.playerInfo2 = playerInfo2;
            return event;
        }

        sizePlayerInfos() {
            return this.playerInfo1.size + this.playerInfo2.size;
        }

        readPlayerInfos(dataReader) {
            this.playerInfo1 = new PlayerInfo();
            this.playerInfo1.read(dataReader);
            this.playerInfo2 = new PlayerInfo();
            this.playerInfo2.read(dataReader);
        };

        writePlayerInfos(dataWriter) {
            this.playerInfo1.write(dataWriter);
            this.playerInfo2.write(dataWriter);
            // console.log("writing playerinfos");
        }

        handlePlayerInfos() {
            game.playerInfos = [];
            game.playerInfos.push(this.playerInfo1);
            game.playerInfos.push(this.playerInfo2);
            game.self.playerInfo = game.playerInfos[game.selfIndex];

            if (game.playerInfos[game.selfIndex].color == game.playerInfos[1-game.selfIndex].color) {
                let color = game.COLORS.find(c => c.id != game.playerInfos[1-game.selfIndex].color);
                if (color) {
                    game.playerInfos[1-game.selfIndex].color = color.id;
                }
            }

            if (game.shooterIndex >=0 && game.shooterIndex <= 1) {
                game.changeStick(game.playerInfos[game.shooterIndex]);
            }
            game.gui.matchDisplay.refreshPlayerInfos();
        }


        static BallHit(force) {
            let event = new MatchEvent(MatchEventTypes.BallHit);
            event.force = force;
            return event;
        }

        sizeBallHit() {
            return 1;
        }

        readBallHit(dataReader) {
            this.force = dataReader.readUint8();
        };

        writeBallHit(dataWriter) {
            dataWriter.writeUint8(this.force);
        }

        handleBallHit() {
            game.soundEngine.playRandomSound("hit",1,4).setVolume(this.force);
        }


        static WallHit(force) {
            let event = new MatchEvent(MatchEventTypes.WallHit);
            event.force = force;
            return event;
        }

        sizeWallHit() {
            return 1;
        }

        readWallHit(dataReader) {
            this.force = dataReader.readUint8();
        };

        writeWallHit(dataWriter) {
            dataWriter.writeUint8(this.force);
        }

        handleWallHit() {
            game.soundEngine.playRandomSound("wall",1,4).setVolume(this.force);
        }


        static Timer(time, player) {
            let event = new MatchEvent(MatchEventTypes.Timer);
            event.time = time;
            event.player = player;
            return event;
        }

        sizeTimer() {
            return 2;
        }

        readTimer(dataReader) {
            this.time = dataReader.readUint8();
            this.player = dataReader.readUint8();
        };

        writeTimer(dataWriter) {
            dataWriter.writeUint8(this.time);
            dataWriter.writeUint8(this.player);
        }

        handleTimer() {
            game.gui.matchDisplay.matchDisplayScreen.setClock(this.time, this.player);
            if (game.selfIndex == game.shooterIndex && this.time == 5) {
                game.soundEngine.playSound("5sec");
                game.chatSystem.addSystemMessage("You have 5 seconds left to shoot! Hurry up!");
            }
        }


        static PuckEvent() {
            let event = new MatchEvent(MatchEventTypes.PuckEvent);
            return event;
        }

        sizePuckEvent() {
            return 0;
        }

        readPuckEvent(dataReader) {
        };

        writePuckEvent(dataWriter) {
        }

        handlePuckEvent() {
            game.soundEngine.playSound("puck").setVolume(50);
        }

        static Disconnect(player1, player2) {
            let event = new MatchEvent(MatchEventTypes.Disconnect);
            event.player1 = player1;
            event.player2 = player2;
            return event;
        }

        sizeDisconnect() {
            return 10;
        }

        readDisconnect(dataReader) {
            this.player1Score = dataReader.readUint8();
            this.player1Fouls = dataReader.readUint8();
            this.player1MaxTrickshot = dataReader.readUint8();
            this.player1MaxStreak = dataReader.readUint8();
            this.player1Accuracy = dataReader.readUint8();

            this.player2Score = dataReader.readUint8();
            this.player2Fouls = dataReader.readUint8();
            this.player2MaxTrickshot = dataReader.readUint8();
            this.player2MaxStreak = dataReader.readUint8();
            this.player2Accuracy = dataReader.readUint8();
        };

        writeDisconnect(dataWriter) {
            dataWriter.writeUint8(this.player1.score);
            dataWriter.writeUint8(this.player1.fouls);
            dataWriter.writeUint8(this.player1.maxTrickshot);
            dataWriter.writeUint8(this.player1.maxStreak);
            dataWriter.writeUint8(this.player1.shots ? Math.round((this.player1.shotsScored/this.player1.shots)*100) : 0);

            dataWriter.writeUint8(this.player2.score);
            dataWriter.writeUint8(this.player2.fouls);
            dataWriter.writeUint8(this.player2.maxTrickshot);
            dataWriter.writeUint8(this.player2.maxStreak);
            dataWriter.writeUint8(this.player2.shots ? Math.round((this.player2.shotsScored/this.player2.shots)*100) : 0);
        }

        handleDisconnect() {
            game.playerStates[0].score = this.player1Score;
            game.playerStates[0].fouls = this.player1Fouls;
            game.playerStates[0].maxTrickshot = this.player1MaxTrickshot;
            game.playerStates[0].maxStreak = this.player1MaxStreak;
            game.playerStates[0].accuracy = this.player1Accuracy;

            game.playerStates[1].score = this.player2Score;
            game.playerStates[1].fouls = this.player2Fouls;
            game.playerStates[1].maxTrickshot = this.player2MaxTrickshot;
            game.playerStates[1].maxStreak = this.player2MaxStreak;
            game.playerStates[1].accuracy = this.player2Accuracy;

            game.chatSystem.addSystemMessage(game.playerInfos[1-game.selfIndex].userName + " has left the game.");
            game.gui.matchDisplay.opponentDisconnected();
        };
    }


    var fromRGB = function(r, g, b) {
        return "rgb(" + r + "," + g + "," + b + ")";
    };

    var fromRGBA = function(r, g, b, a) {
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
    };

    var MatchStates = {
        waiting: 0,
        idle: 1,
        end: 2,
        shooting: 3,
        penalty: 4,
        puckPenalty: 5,
        aim: 6,
        simulation: 7
    };

    class game_core {
        constructor(game_instance) {
            game = this;
            this.instance = game_instance;
            this.server = this.instance !== undefined;
            this.players = [];
            this.border = [];

            this.projectiles = [];
            this.collectibles = [];
            this.events = [];
            this.eventTypes = [];
            this.collectibleTypes = [];

            if (!this.server) {
                this.pixiContainer = new PIXI.Container();
                this.stage = new PIXI.Container();
                this.pixiContainer.addChild(this.stage);
            }

            this.registerEvent(MatchEvent);
            //	this.initBorders();
        }

        registerEvent(EventClass) {
            this.eventTypes.push(EventClass);
            EventClass.type = this.eventTypes.length - 1;
        }

        registerCollectible(CollectibleClass) {
            this.collectibleTypes.push(CollectibleClass);
            return this.collectibleTypes.length - 1;
        }

        create_physics_simulation() {
            setInterval(function () {
                this.update_physics();
            }.bind(this), this.server ? Config.serverFrameTime : Config.clientFrameTime);
        }

        remove_player(clientId) {
            if (this.server) {
                var player = this.get_player_by_user(clientId);
                if (player && player.body) {
                    this.removeAllBody(player);
                }
            }
            this.players = this.players.filter(p => p.clientId != clientId);
        }

        get_player_by_user(clientId) {
            return this.players.find(p => p.clientId == clientId);
        }

        get_player(id, includeDisconnected) {
            if (!id) {
                return;
            }
            var player = this.players.find(p => p.id == id);
            if (includeDisconnected && !player) {
                player = this.disconnectedPlayers.find(p => p.id == id);
            }
            return player;
        }
    }


    class AssetManager {
        constructor(assetsToLoad, soundEngine) {
            this.assetsToLoad = assetsToLoad;
            this.loadedCount = 0;
            this.images =[];
            this.texts = [];
            this.textures = [];
            this.spritesheets = [];
            this.animations = [];
            this.totalCount = assetsToLoad.texts.length +
                assetsToLoad.images.length +
                assetsToLoad.spritesheets.length * 2 +
                assetsToLoad.animations.length * 3+
                assetsToLoad.sounds.length;
            this.completedCount = 0;
            this.materialsLoaded = 0;
            this.soundEngine = soundEngine;
        }



        preloadAssets(onFinished) {
            this.onProgress = function ( xhr ) {
                if ( xhr.lengthComputable ) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log( Math.round(percentComplete, 2) + '% downloaded' );
                }
            };

            this.onError = function ( xhr ) {
                console.error( "Error during preload!" );
            };
            this.onFinished = onFinished;
            this.preloadTexts();
            //  this.preloadImages();

            this.preloadPIXI();

            this.preloadSounds();
            if (this.completedCount == this.totalCount) {
                this.onFinished();
            }
        }

        preloadPIXI() {
            this.assetsToLoad.spritesheets.forEach(spritesheet => {
                PIXI.loader
                    .add(spritesheet.nickname, 'assets/textures/'+spritesheet.nickname+'.json')
                this.spritesheets.push({nickname:spritesheet.nickname})
            })

            this.assetsToLoad.animations.forEach(animation => {
                PIXI.loader
                    .add(animation.nickname, 'assets/animations/'+animation.nickname+'.json')
                this.animations.push({nickname:animation.nickname})
            })

            PIXI.loader.onLoad.add((loader, resource) => {
                this.assetLoaded();
            });
            PIXI.loader.load();
        }

        preloadTexts() {
            this.assetsToLoad.texts.forEach(text => {
                var request = new XMLHttpRequest();
                request.onreadystatechange =() => {
                    if (request.readyState == XMLHttpRequest.DONE) {
                        if (request.status >= 200 && request.status < 300) {
                            this.texts.push({nickname: text.nickname, text: request.responseText});
                            this.assetLoaded();
                        }
                        else {
                            _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
                            if (error)
                                error(path, "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
                        }
                    }
                };
                request.open("GET", text.path, true);
                request.send();
            });
        }

        preloadSounds() {
            this.assetsToLoad.sounds.forEach(s => {
                this.soundEngine.addSound(s.nickname, s.path);
            })
            this.soundEngine.preloadSounds(this.assetLoaded.bind(this));
        }

        assetLoaded() {
            ++this.completedCount;

            //var progress= Math.round((this.completedCount / this.totalCount) * 100);
            //document.getElementById("preloadProgress").innerHTML = progress + "%";
            if (this.completedCount == this.totalCount) {
                this.onFinished();
            }
        }

        getImage(nickname) {
            for (let asset of this.images) {
                if (asset.nickname == nickname) {
                    return asset.image;
                }
            }
            return ;
        }

        getText(nickname) {
            for (let asset of this.texts) {
                if (asset.nickname == nickname) {
                    return asset.text;
                }
            }
            return null;
        }

        getTexture(nickname) {
            for (let asset of this.textures) {
                if (asset.nickname == nickname) {
                    return asset.texture;
                }
            }
            return null;
        }

        getAnimation(nickname) {
            for (let asset of this.animations) {
                if (asset.nickname == nickname) {
                    return asset.animation;
                }
            }
            return null;
        }
    }

    class ChatSystem {
        constructor() {
            this.chatContainer = document.getElementById("chatcontainer");
            this.chatInput = document.getElementById("chatinput");
            this.chatInputContainer = document.getElementById("chatinputcontainer");
            this.chatEnter = document.getElementById("chatenter");
            this.chatMute = document.getElementById("mutechat");
            this.chatMessages = document.getElementById("chatmessages");
            this.enabled = false;
            this.shown = false;
            this.muted = false;
            this.messageElems = [];

            document.getElementById("chatinputform").addEventListener("submit", (e) => {
                e.preventDefault();
                this.storeChatMessage();
                return false;
            });

            this.chatEnter.addEventListener("click", (e) => {
                this.enableChat();
                return false;
            });

            this.chatMute.addEventListener("click", (e) => {
                this.toggleMute();
                return false;
            });

            this.messages = [];
        }

        show() {
            this.chatContainer.style.display = "flex";
            this.shown = true;
        }

        hide() {
            this.chatContainer.style.display = "none";
            this.shown = false;
        }

        disableChat() {
            this.chatInput.blur();
            this.chatInputContainer.style.display = 'none';
            this.chatEnter.style.display = 'flex';
            this.chatMessages.style.backgroundColor= "rgba(6,22,26,0)";
            this.chatMessages.style.overflowY = "hidden";
            this.chatMessages.style.pointerEvents ="none";
            this.enabled = false;
        }

        enableChat() {
            if (game.lastSentMessage && Date.now() - game.lastSentMessage < 1000) {
                return;
            }

            this.chatEnter.style.display = 'none';
            this.chatInputContainer.style.display = 'flex';
            this.chatInput.focus();

            this.chatMessages.style.overflowY = "auto";
            this.chatMessages.style.backgroundColor= "rgba(6,22,26,0.5)";
            this.chatMessages.style.pointerEvents ="visible";

            this.enabled = true;
            this.messageElems.forEach(m=> {
                m.fadeTime = 8000;
                m.elem.style.display = "flex";
            })
        }

        toggleMute() {
            this.muted = !this.muted;
            if (this.muted) {
                this.disableChat();
                this.chatEnter.style.opacity = 0.5;
                this.chatEnter.style.pointerEvents = "none";
            } else {
                this.chatEnter.style.opacity = 1;
                this.chatEnter.style.pointerEvents = "visible";
            }
        }

        toggleChat() {
            if (this.enabled) {
                this.disableChat();
            } else {
                this.enableChat();
            }
        }

        storeChatMessage() {
            var message = this.chatInput.value;
            if (message !== '') {
                this.chatInput.value = '';
                if ((message !== this.lastChatMessage) &&
                    (!this.lastSentMessage || Date.now() - this.lastSentMessage  > 500)) {
                    if (message[0] == '!') {
                        game.portalsocket.emit('srvcmd', message);
                    } else {
                        this.messages.push(message);
                        if (message[0] != '!' && message[0] != '\\'){
                            this.lastChatMessage = message;
                            this.lastSentMessage = Date.now();
                        }
                    }
                }
            }
        }

        clearChat() {
            this.chatMessages.innerHTML = "";
            this.messageElems = [];
        }

        addMessageElem(message, style) {
            var div = document.createElement('div');
            div.className = style;
            div.innerHTML = censore(message, game.regexp);
            this.chatMessages.appendChild(div);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            this.messageElems.push({elem: div, fadeTime: 8000});
        }

        addSystemMessage(message) {
            this.addMessageElem(message, 'chatmessage systemmessage');
        }

        addAnnouncement(message) {
            this.addMessageElem(message, 'chatmessage announcement');
        }

        addMessage(playerIndex, message) {
            if (this.muted)
                return;
            let playerInfo = game.playerInfos[playerIndex];
            let color = game.getColor(playerInfo.color).text;
            //color = "#31cfdd";
            if (this.shown) {
                if (playerIndex == game.selfIndex) {
                    game.soundEngine.playSound("chat");
                } else {
                    game.soundEngine.playSound("chatOther");
                }
            }

            let rankText = playerInfo.rank ? "LV"+playerInfo.rank : "";
            this.addMessageElem(rankText+'[<span style="font-weight:bold;color:'+color+'">'+playerInfo.userName+'</span>]: '+message, 'chatmessage');
        }


        getMessagesLength() {
            var length = 1;
            this.messages.forEach(message => {
                length += (message.length + 1)*4;
            });
            return length;
        }

        serializeMessages(dataWriter) {
            dataWriter.writeUint8(this.messages.length);
            this.messages.forEach(message => {
                dataWriter.writeString(message);
            });
        }

        clearMessages() {
            this.messages = [];
        }

        update() {
            this.messageElems.forEach(m => {
                if (m.fadeTime > 0 && !this.enabled) {
                    m.fadeTime -= Config.clientFrameTime;
                    if (m.fadeTime <= 0) {
                        $(m.elem).fadeOut(1000);
                    }
                }
            })
        }
    }



// KeyboardState

    class KeyboardState	 {
        constructor() {
            this.keyCodes	= {};
            this.modifiers	= {};
            this.wasPressedKeys = {};

            var self	= this;
            this._onKeyDown	= function(event){ self._onKeyChange(event, true); };
            this._onKeyUp	= function(event){ self._onKeyChange(event, false);};

            document.addEventListener("keydown", this._onKeyDown, false);
            document.addEventListener("keyup", this._onKeyUp, false);

            KeyboardState.MODIFIERS_	= ['shift', 'ctrl', 'alt', 'meta'];
            KeyboardState.ALIAS_	= {
                'left'		: 37,
                'up'		: 38,
                'right'		: 39,
                'down'		: 40,
                'space'		: 32,
                'pageup'	: 33,
                'pagedown'	: 34,
                'tab'		: 9,
                'enter'		: 13
            };
        }

        destroy() {
            document.removeEventListener("keydown", this._onKeyDown, false);
            document.removeEventListener("keyup", this._onKeyUp, false);
        }

        _onKeyChange(event, pressed) {
            var keyCode		= event.keyCode;
            this.keyCodes[keyCode]	= pressed;
            if (pressed) {
                this.wasPressedKeys = {};
            }

            this.modifiers['shift']= event.shiftKey;
            this.modifiers['ctrl']	= event.ctrlKey;
            this.modifiers['alt']	= event.altKey;
            this.modifiers['meta']	= event.metaKey;
        }

        pressed(keyDesc) {
            var keys	= keyDesc.split("+");
            for(var i = 0; i < keys.length; i++){
                var key		= keys[i];
                var pressed;
                if( KeyboardState.MODIFIERS_.indexOf( key ) !== -1 ){
                    pressed	= this.modifiers[key];
                }else if( Object.keys(KeyboardState.ALIAS_).indexOf( key ) != -1 ){
                    pressed	= this.keyCodes[KeyboardState.ALIAS_[key] ];
                }else {
                    pressed	= this.keyCodes[key.toUpperCase().charCodeAt(0)]
                }
                if( !pressed)	return false;
            };
            return true;
        }

        wasPressed(key) {
            if (this.pressed(key) && !this.wasPressedKeys[key]) {
                this.wasPressedKeys[key] = true;
                return true;
            }
            return false;
        }
    }

    var createArray2D = function(n, m) {
        let arr = new Array(n);
        for (let i = 0; i < n; i++) {
            arr[i] = new Array(m);
        }
        return arr;
    }

    class game_core_client extends game_core {
        constructor() {
            super();

            //Create the renderer
            this.renderer = PIXI.autoDetectRenderer({
                width: window.innerWidth * Config.canvasRes,
                height: window.innerHeight * Config.canvasRes,
                antialias: true
            });
            this.renderer.plugins.interaction.moveWhenInside = true;

            //Add the canvas to the HTML document
            this.renderer.view.style.position = "absolute";
            this.renderer.view.style.left = 0;
            this.renderer.view.style.top = 0;
            this.renderer.backgroundColor = 0x0f404b;
            document.body.appendChild(this.renderer.view);

            //Create a container object called the `stage`
            this.stage = new PIXI.Container();

            //Tell the `renderer` to `render` the `stage`
            this.renderer.render(this.stage);
            this.viewport = this.renderer.view;

            this.stats = new Stats();
            document.getElementById("controls-container").appendChild(this.stats.domElement);

            this.disconnectedPlayers = [];
            this.keyboard = new KeyboardState();
            this.client_create_configuration();
            //A list of recent server updates we interpolate across
            //This is the buffer that is the driving factor for our networking
            this.client_logged_in = false;
            this.client_connect_to_portal();
            this.client_create_ping_timer();
            this.preloadCompleted = false;
            this.client_typing = false;

            this.leaderboard=[];
            this.maxLeaderboardNum = 10;

            this.showDebug = false;
            this.showChat = false;

            this.gui = new GUI (this);
            this.chatSystem = new ChatSystem();
            this.showIds = false;
            this.items = [];
            this.uploads = [];

            this.adplayer = 0;
            setInterval(() => this.client_handle_input(), Config.clientInputRate);

            this.initAds();

            this.tableColor = [ 78, 255, 244 ]; // RGB array
            this.tableBrightness = 1.7;
            this.tableDecal = 1;
        }

        modelToScreen(x, y) {
            return {
                x: x * game.table.scale + game.viewport.width / 2 - game.table.scale * 1112 / 2,
                y: y * game.table.scale + game.viewport.height / 2 - game.table.scale * 626 / 2
            }
        }

        get selfColor() {
            return this.getColor(this.playerInfos[this.selfIndex].color);
        }

        get opponentColor() {
            return this.getColor(this.playerInfos[1 - this.selfIndex].color);
        }

        get opponent() {
            return this.playerInfos[1 - this.selfIndex];
        }

        setState(state) {
            if (state == MatchStates.aim && this.shooter && !this.wasFirstShoot) {
                this.wasFirstShoot = true;
                this.table.tip.setText("Aim your stick at your <opponent>opponent’s color</opponent>. Press LMB, hold, drag back to set power then release");
            }

            if (state != MatchStates.penalty && this.state == MatchStates.penalty) {
                this.table.white.reset();
            } else if (state != MatchStates.puckPenalty && this.state == MatchStates.puckPenalty) {
                this.table.puck.reset();
            }
            this.state = this.table.state = state;
        }

        windowResized() {
            let matchDisplayScreen = document.getElementById("matchdisplayscreen");
            matchDisplayScreen.style.marginTop = Math.min(30, Math.max(0, window.innerHeight - 700)) + "px";

            let mobile = window.mobileAndTabletcheck();
            let minWidth = mobile ? 1000 : 1040;

            if (window.innerWidth < minWidth || window.innerHeight < 440) {
                let scale = Math.min(
                    window.innerWidth / minWidth,
                    window.innerHeight / 440
                );

                let gui = document.getElementById("centermiddle");
                gui.style.transformOrigin = "50% 50%";
                gui.style.transform = "scale(" + scale + ")";

                let guibot = document.getElementById("rightbottom");
                guibot.style.transformOrigin = "50% 50%";
                guibot.style.transform = "scale(" + scale + ")";
                // $('#centermiddle').height($('#centermiddle').width() / 16 * 9);
                // window.scrollTo(0,1);
            }

            if (window.innerWidth < 1020) {
                let scale =  window.innerWidth / 1020;
                if (mobile) {
                    scale *= 0.7;
                }
                matchDisplayScreen.style.transformOrigin = "50% 0";
                matchDisplayScreen.style.transform = "scale(" + scale + ")";
            }
            document.getElementById("centerbottom").style.display = window.innerHeight < 520 ? "none" : "flex";

            if (mobile) {
                document.getElementById("leftmenu").style.margin = 0;
                matchDisplayScreen.style.position = "relative";
                matchDisplayScreen.style.left = "30px";

                let vs = document.getElementById("results");
                vs.style.background = 0;
                vs.style.margin = 0;
            }

            this.viewport.width = window.innerWidth * Config.canvasRes;
            this.viewport.height = window.innerHeight * Config.canvasRes;

            let w = this.viewport.width;
            let h = this.viewport.height;
            this.renderer.resize(w, h);

            this.stage.position.set(w / 2, h / 2);

            if (game.table) {
                game.table.onResize();
            }
        }

        initListeners() {

            if (!window.googleScript) {
                var head= document.getElementsByTagName('head')[0];
                window.googleScript = document.createElement("script");
                window.googleScript.type = "text/javascript";
                window.googleScript.async = true;
                window.googleScript.defer = true;
                window.googleScript.src = "https://apis.google.com/js/platform.js";
                window.googleScript.addEventListener("load", () => { onLoadGAPI(); });
                head.appendChild(window.googleScript);
            }

            $(".hoverimg").hover(function(){
                $('#'+this.id).attr('src','assets/'+this.alt+'.svg');
            }, function(){
                $('#'+this.id).attr('src','assets/'+this.alt+'-roll.svg');
            });

            $(".hoverarrowbtn").hover(function(){
                let imgElem = document.getElementById(this.id+"img");
                imgElem.src = 'assets/'+imgElem.alt+'.svg';
            }, function(){
                let imgElem = document.getElementById(this.id+"img");
                imgElem.src = 'assets/'+imgElem.alt+'-roll.svg';
            });

            $(".btn").hover(function(){
                $('#'+this.id).removeClass("btnnormal");
                $('#'+this.id).addClass("btnhover");
            }, function(){
                $('#'+this.id).removeClass("btnhover");
                $('#'+this.id).addClass("btnnormal");
            });

            $(".itemcommon").hover(function(){
                $('#'+this.id).removeClass("itemcommon");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemcommon");
            });

            $(".itemuncommon").hover(function(){
                $('#'+this.id).removeClass("itemuncommon");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemuncommon");
            });

            $(".itemrare").hover(function(){
                $('#'+this.id).removeClass("itemrare");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemrare");
            });

            $(".itemepic").hover(function(){
                $('#'+this.id).removeClass("itemepic");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemepic");
            });

            $(".itemlegendary").hover(function(){
                $('#'+this.id).removeClass("itemlegendary");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemlegendary");
            });

            $(".itemunique").hover(function(){
                $('#'+this.id).removeClass("itemunique");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemunique");
            });

            $(".itemequipped").hover(function(){
                $('#'+this.id).removeClass("itemequipped");
                $('#'+this.id).addClass("itemhover");
            }, function(){
                $('#'+this.id).removeClass("itemhover");
                $('#'+this.id).addClass("itemequipped");
            });

            var checkSize = function () {
                if (window.innerWidth < 1000) {
                    $("#pockey_adcontainer").hide();
                } else {
                    $("#pockey_adcontainer").show();
                }
            };

            checkSize();

            window.addEventListener("resize", () => {
                this.windowResized();
                checkSize();
            });
            document.getElementById("loginscreen").addEventListener("submit", (e) => {
                e.preventDefault();
                if (this.portalsocket && this.portalsocket.connected) {
                    this.client_enterAttempt();
                }
                return false;
            });

            document.getElementById("login").addEventListener("click", (e) => {
                e.preventDefault();
                if (this.portalsocket && this.portalsocket.connected) {
                    this.client_enterAttempt();
                }
                return false;
            });

            document.getElementById("serverlist").addEventListener("change", (e) => {
                // this.client_connect_to_server();
                document.getElementById('login_name').focus();
                return false;
            });


            document.getElementById("fbBtn").addEventListener("click", (e) => {
                handleFBLogin();
                return false;
            });

            document.getElementById("googleBtn").addEventListener("click", (e) => {
                handleGoogleLogin();
                return false;
            });

            document.getElementById("logoutBtn").addEventListener("click", (e) => {
                logout();
                return false;
            });

            document.getElementById("rematch").addEventListener("click", (e) => {
                this.requestRematch();
                this.gui.matchDisplay.rematchRequested();
                return false;
            });

            document.getElementById("newmatch").addEventListener("click", (e) => {
                if ((game.self.playerInfo.wins +game.self.playerInfo.losses) % 3 == 0) {
                    aiptag.cmd.player.push(() => { game.adplayer.startPreRoll(); });
                    document.getElementById("matchstatescreen").style.marginTop = "40px";
                } else {
                    document.getElementById("matchstatescreen").style.marginTop = "0px";
                    this.requestNewMatch();
                }
                this.gui.matchDisplay.searchMatch();
                return false;
            });

            document.getElementById("playgame").addEventListener("click", (e) => {
                this.gui.selectPlayGame();
                return false;
            });

            document.getElementById("inventory").addEventListener("click", (e) => {
                this.gui.selectInventory();
                return false;
            });

            document.getElementById("invite").addEventListener("click", (e) => {
                this.gui.selectInvite();
                return false;
            });

            document.getElementById("allstars").addEventListener("click", (e) => {
                this.gui.selectAllStars();
                return false;
            });

            document.getElementById("invitebtn").addEventListener("click", (e) => {
                this.getInviteLink();
                return false;
            });

            document.getElementById("copybtn").addEventListener("click", function() {
                copyToClipboardMsg(document.getElementById("invitelink"), "copymsg");
                return false;
            });

            document.getElementById("howtotext").addEventListener("click", function() {
                if (document.getElementById("promo").style.display == "none") {
                    document.getElementById("promo").style.display = "flex";
                    document.getElementById("fbshare").style.display = "flex";
                    document.getElementById("twlink").style.display = "flex";
                    document.getElementById("howtogif").style.display = "none";
                } else {
                    document.getElementById("promo").style.display = "none";
                    document.getElementById("fbshare").style.display = "none";
                    document.getElementById("twlink").style.display = "none";
                    document.getElementById("howtogif").style.display = "flex";
                }
                return false;
            });

            document.getElementById("promoform").addEventListener("submit", (e) => {
                e.preventDefault();
                if (this.portalsocket && this.portalsocket.connected) {
                    this.sendPromoCode();
                }
                return false;
            });

            document.getElementById("promobtn").addEventListener("click", (e) => {
                e.preventDefault();
                if (this.portalsocket && this.portalsocket.connected) {
                    this.sendPromoCode();
                }
                return false;
            });


            document.getElementById("fbshare").addEventListener("click", (e) => {
                //e.preventDefault();
                FB.ui({
                    method: 'share',
                    href: 'https://pockey.io',
                    quote: 'I am playing https://pockey.io.',
                    display: 'popup'
                }, (response) => {
                    if (response) {
                        if (this.portalsocket && this.portalsocket.connected) {
                            this.sendCustomCode("fbshare");
                        }
                    } else {
                        console.log("not shared");
                    }
                });
            });

        }

        initColors() {
            this.COLORS = [];
            this.items.forEach(item => {
                if (item.type == "color") {
                    this.COLORS.push(item);
                }
            });
        }

        getColor(id) {
            return this.COLORS.find(c => c.id == id);
        }

        initAvatars() {
            this.avatars = [];
            this.items.forEach(item => {
                if (item.type == "avatar") {
                    let avatar = item;
                    avatar.fileName = "avatar"+ item.id + ".png";
                    this.avatars.push(item);
                }
            });
        }

        getAvatar(id) {
            return this.avatars.find(a => a.id == id);
        }

        getStick(id) {
            return this.items.find(i => i.type == "stick" && i.id == id);
        }

        initDecals() {
            this.decals = [];
            this.items.forEach(item => {
                if (item.type == "decal") {
                    this.decals.push(item);
                }
            });
        }

        getDecal(id) {
            return this.decals.find(d => d.id == id);
        }

        getFelt(id) {
            return this.items.find(i => i.type == "felt" && i.id == id);
        }

        initGame() {
            this.self = new Player(this);

            this.initListeners();
            this.initPIXIResources();
            this.initColors();
            this.initAvatars();
            this.initDecals();

            this.mouse = new MouseHandler(game);

            this.windowResized();

            this.customizer = new Customizer();

            //this.client_connect_to_server();
            this.create_physics_simulation();


            this.table = new Table();
            this.table.init(this.stage);
            this.table.touchStickContainer.interactive = true;
            this.table.touchStickContainer.on('pointerdown', (event) => {
                this.touchShoot = true;
            });
            this.table.touchStickContainer.on('pointermove', (event) => {
                this.mouse.moveTarget(event.column.global.x, event.column.global.y);
            });
            this.table.touchStickContainer.on('pointerup', (event) => {
                this.touchShoot = false;
            });

            this.table.table.interactive = true;
            this.table.table.on('pointerdown', (event) => {
                this.mouse.moveTarget(event.column.global.x - 30, event.column.global.y);
                if (this.table.state == MatchStates.aim && this.shooter && window.mobileAndTabletcheck()) {
                    let modelCoord = this.mouse.screenToModel(event.column.global);
                    let angle = modelCoord.sub(this.table.white.position).angle();
                    this.touchAim = {
                        stickStart: this.table.stickAngle,
                        touchStart: angle,
                        prevAngle: angle
                    };
                }
            });
            this.table.table.on('pointermove', (event) => {
                this.mouse.moveTarget(event.column.global.x - 30, event.column.global.y);
            });
            this.table.table.on('pointerup', (event) => {
                delete this.touchAim;
            });

            this.menuBG = new PIXI.Container();
            this.menuBGPic = new PIXI.Sprite(game.assetManager.getTexture("bg_pockey.png"));
            this.menuBG.position.set(-960,-540);
            this.menuBG.alpha = 0;
            this.menuBG.visible = false;
            this.menuBG.addChild(this.menuBGPic);

            this.menuBGCue = new PIXI.Sprite(game.assetManager.getTexture("menu_sprite-cue.png"));
            this.menuBGCue.position.set(0,800);
            this.menuBG.addChild(this.menuBGCue);

            this.menuBGBall;
            if (Math.random() < 0.5) {
                this.menuBGBall = new PIXI.Sprite(game.assetManager.getTexture("menu_sprite-e.png"));
            } else {
                this.menuBGBall = new PIXI.Sprite(game.assetManager.getTexture("menu_sprite-sevn.png"));
            }
            this.menuBGBall.position.set(1400,600);
            this.menuBG.addChild(this.menuBGBall);

            this.stage.addChild(this.menuBG);

            this.inited = true;
            window.requestAnimationFrame(this.renderFrame.bind(this));

            this.initTop10List();
            this.initHpBars();
            this.initScoreBars();
            this.inviteId = GetURLParameter('i');

            this.inventory = this.guestInventory;
            this.coins = 0;
            this.customizer.playerInfoUpdated();
            this.gui.inventoryScreen.inventoryPage = 0;
            this.gui.inventoryScreen.setup();

            if (!document[hidden]) {
                this.client_loginAttempt();
            }

            this.client_create_debug_gui();

            twttr.ready( (twttr) => {
                twttr.widgets.load();

                twttr.events.bind('follow', (event) => {
                    var followedScreenName = event.column.screen_name;
                    if (followedScreenName == "starcadeio")
                        this.sendCustomCode("twfollow");
                });
            })
        }

        initPIXIResources() {
            var resources = PIXI.loader.resources;
            this.assetManager.spritesheets.forEach(spritesheet => {
                for (let texture in resources[spritesheet.nickname].textures) {
                    this.assetManager.textures.push({nickname: texture, texture: resources[spritesheet.nickname].textures[texture]})
                }
            });

            this.assetManager.animations.forEach(animation => {
                animation.animation = resources[animation.nickname].spineData;
            });
        }

        requestRematch() {
            this.socket.emit("requestrematch");
        }

        requestNewMatch() {
            if (this.socket.connected)
                this.socket.disconnect();
            delete this.socket;
            this.players = [];
            this.portalsocket.emit("requestnewmatch");
        }

        sendPromoCode() {
            let promoCode = document.getElementById("promocode").value;
            if (promoCode && promoCode.length) {
                this.portalsocket.emit("promocode", promoCode);
            }
        }

        sendCustomCode(code) {
            this.portalsocket.emit("promocode", code);
        }
        /*
    initEffects() {

        this.animSpriteManager = new AnimatedSpriteManager(this);

        var effects = [];
        this.assetManager.texts.forEach(file => {
            if (file.nickname.startsWith('effects') && file.nickname.endsWith('json')) {
                let column = JSON.parse(file.text);
                for (let path in column.frames) {
                    let parts = path.split('/');
                    let frame = column.frames[path];
                    let nickname = parts[0];
                    frame.index = parts[1].substring(nickname.length + 1, nickname.length + 1 + 2);
                    var effect = effects.find(e => e.nickname == nickname);
                    if (!effect) {
                        effect = {};
                        effect.frames = [];
                        effect.texture = this.assetManager.getTexture(file.nickname.replace('json', 'png'));
                        effect.width = frame.frame.w;
                        effect.height = frame.frame.h;
                        effect.nickname = nickname;
                        effects.push(effect);
                    }
                    frame.uvX0 = frame.frame.x/2048.0;
                    frame.uvY0 = frame.frame.y/2048.0;
                    frame.uvX1 = (frame.frame.x+effect.width)/2048.0;
                    frame.uvY1 = (frame.frame.y+effect.height)/2048.0;
                    effect.frames.push(frame);
                }
                //this.effects[nickname].push({ frame: column.frames[path], index: index, path: path });
            }
        });

        effects.forEach(effect =>{
            this.animSpriteManager.addSprite(effect);
        });
    }
  */
        renderFrame() {
            var time = Date.now();
            // Recommendation from Opera devs: calling the RAF shim at the beginning of your
            // render loop improves framerate on browsers that fall back to setTimeout

            if(this.stats) { this.stats.begin(); }
            this.renderer.render(this.stage);

            if(this.stats) { this.stats.end(); }
            window.requestAnimationFrame(this.renderFrame.bind(this));
        }

        showAd() {
            if (window.innerHeight < 490 || window.innerWidth < 320) {
                return;
            }
//		$("#adcontainer" ).fadeIn( "slow");
        }

        interpolateObject(obj) {
            if (obj.jumped || obj.hiddenPrev) {
                obj.jumped = false;
                obj.x = obj.targetX;
                obj.y = obj.targetY;
                if (obj.targetAngle) {
                    obj.angle = obj.targetAngle;
                }
                return;
            }

            let dx = obj.targetX - obj.x;
            let dy = obj.targetY - obj.y;
            if (Math.abs(dx) > world.width / 2) {
                obj.x += dx;
            }
            if (Math.abs(dy) > world.height / 2) {
                obj.y += dy;
            }

            if (Math.abs(dx) > 0.1) {
                obj.x = lerp(obj.x, obj.targetX, Config.interpolationRate);
            }
            if (Math.abs(dy) > 0.1) {
                obj.y = lerp(obj.y, obj.targetY, Config.interpolationRate);
            }
            if (obj.targetAngle) {
                obj.angle = lerp(obj.angle, obj.targetAngle, Config.interpolationRate);
            }
        }

        update_physics() {
            this.mouse.update();

            /*
        this.players.forEach(obj => obj.updateClient(delta));
        if (this.animSpriteManager) {
            this.animSpriteManager.update(delta);
        }
*/

            this.table.update();

            this.updateClient();
        }

        updateClient() {
            if (this.menuFading) {
                if (this.menuBG.alpha >= 1.0) {
                    this.menuBG.alpha = 1.0;
                } else {
                    this.menuBG.alpha += 0.005;
                }
            }
            this.gui.notificator.update();
            this.chatSystem.update();
        }

        initAipPreroll() {
            if(typeof aipPlayer != "undefined") {
                this.adplayer = new aipPlayer({
                    AD_WIDTH: 960,
                    AD_HEIGHT: 540,
                    AD_FULLSCREEN: false,
                    AD_CENTERPLAYER: false,
                    LOADING_TEXT: 'loading advertisement',
                    PREROLL_ELEM: document.getElementById('mainAdContainer'),
                    AIP_COMPLETE: () =>  {

                        if (!this.client_logged_in) {
                            var userName = document.getElementById("login_name").value.trim();
                            let column = {
                                userName: userName,
                                color: game.self.playerInfo.color,
                                avatar: game.self.playerInfo.avatar
                            }
                            if (this.inviteId) {
                                column.inviteId = game.inviteId;
                            }
                            if (this.portalsocket && this.portalsocket.connected)
                                this.portalsocket.emit("enterAttempt", column);
                        } else {
                            game.requestNewMatch();
                        }

                        /*******************
                         ***** WARNING *****
                         *******************
                         Please do not remove the PREROLL_ELEM
                         from the page, it will be hidden automaticly.
                         If you do want to remove it use the AIP_REMOVE callback below
                         */
                        document.getElementById("matchstatescreen").style.marginTop = "0px";
                        this.prerolling = false;
                    },
                    AIP_REMOVE: function ()  {
                        // Here it's save to remove the PREROLL_ELEM from the page
                        // But it's not necessary
                    }
                });
            } else {
                // Failed to load the adslib ads are probably blocked
                // don't call the startPreRoll function.
                // it will result in an error.
            }
        }

        initAds() {
            getScript('https://api.adinplay.com/player/v2/TMB/pockey.io/player.min.js', this.initAipPreroll.bind(this));
        }


        client_loginAttempt() {
            if (this.client_logged_in || !googleAuth2)
                return;

            if (this.portalsocket && this.portalsocket.connected) {
                var loginType = readCookie("logintype");
                if (!loginType || loginType == "") {
                    game.refreshLoginScreen();
                    return;
                } else if (loginType == "fb") {
                    FB.getLoginStatus(function(response) {
                        if (response.status === 'connected') {
                            var fbToken = response.authResponse.accessToken;
                            var loginData = {
                                fbToken: fbToken
                            };

                            FB.api('/me', { locale: 'en_US', fields: 'nickname, email' },
                                function(response2) {
                                    loginData.nickname = response2.nickname;
                                    loginData.email = response2.email;
                                    this.portalsocket.emit("loginAttempt", loginData);
                                }.bind(this)
                            );

                            FB.Event.subscribe('edge.create', function (response) {
                                alert('Liked');
                            });

                            FB.Event.subscribe('edge.remove', function (response) {
                                alert('DisLiked')
                            });
                        } else {
                            eraseCookie("logintype");
                            game.refreshLoginScreen();
                        }
                    }.bind(this));
                } else if (loginType == "google") {
                    if (googleAuth2.isSignedIn.get()) {
                        var googleUser = googleAuth2.currentUser.get();
                        var email = googleUser.getBasicProfile().getEmail();
                        var loginData = {
                            googleToken: googleUser.getAuthResponse().id_token,
                            email: googleUser.getBasicProfile().getEmail(),
                            nickname: googleUser.getBasicProfile().getName()
                        };
                        this.portalsocket.emit("loginAttempt", loginData);
                    } else {
                        eraseCookie("logintype");
                        game.refreshLoginScreen();
                    }
                }
            }
        }

        client_loginSuccess(column) {
            document.getElementById("login_name").value = column.playerInfo.userName;
            this.self.playerInfo = PlayerInfo.fromData(column.playerInfo);
            this.inventory = column.inventory;
            this.coins = column.coins;
            this.customizer.playerInfoUpdated();
            this.gui.inventoryScreen.inventoryPage = 0;
            this.gui.inventoryScreen.setup();

            this.refreshLoginScreen();
            this.refreshStats();
            this.initTop10List();
            if ((this.self.playerInfo.privilige & UserPriviliges.Kick) == UserPriviliges.Kick) {
                this.chatSystem.show();
            } else {
                this.chatSystem.hide();
            }
        }

        client_logout() {
            delete this.sessionId;
            if (this.portalsocket && this.portalsocket.connected) {
                this.portalsocket.emit("logout");
            }
        }

        client_logoutFinished() {
            if (this.socket) {
                if (this.socket.connected)
                    this.socket.disconnect();
                delete this.socket;
                this.players = [];
            }
            this.client_logged_in = false;
            eraseCookie("logintype");
            document.getElementById("login_name").value = '';
            this.refreshLoginScreen();
            this.self.playerInfo = new PlayerInfo();
            this.inventory = this.guestInventory;
            this.coins = 0;
            this.customizer.playerInfoUpdated();
            this.gui.inventoryScreen.inventoryPage = 0;
            this.gui.inventoryScreen.setup();
            this.initTop10List();
            this.chatSystem.hide();
        }

        client_loginFailed() {
            eraseCookie("logintype");
            this.refreshLoginScreen();
        }

        client_alert(message) {
            window.alert(message);
        }

        client_enterAttempt() {
            if (this.client_logged_in)
                return;

            //temporary hack :(((
            if (this.keyboard.wasPressed('enter'))
                this.keyboard.wasPressedKeys[13] = false;


            aiptag.cmd.player.push(() => { game.adplayer.startPreRoll(); });
            document.getElementById("matchstatescreen").style.marginTop = "40px";

            this.menuBG.visible = false;
            this.table.show();

            this.gui.hideMainAll();
            this.gui.showMatchDisplay();

            // soundManager.fadeTo('music', 3500, 0, function () { soundManager.stop('music'); soundManager.setVolume('music', 100); });

            this.ambientSound = this.soundEngine.loopSound("ambient");
            this.ambientSound.setVolume(50);
            createCookie("userName", document.getElementById("login_name").value);
            if (!window.mobileAndTabletcheck()) {
                this.chatSystem.show();
                this.chatSystem.clearChat();
                this.chatSystem.addSystemMessage("Welcome to Pockey.io!");
                if (this.inviteId){
                    this.chatSystem.addSystemMessage("Waiting for invite");
                    this.gui.matchDisplay.setStateText("Waiting for invite");
                } else {
                    this.chatSystem.addSystemMessage("Searching for opponent");
                }
            }
            this.startSearchAnimation();

        }


        client_enterSuccess(column) {
            this.client_logged_in = true;
            this.self.playerInfo = PlayerInfo.fromData(column.playerInfo);
            this.changeStick(this.self.playerInfo);
            this.changeTable(this.self.playerInfo);
            this.sessionId = column.sessionId;
            if (this.inviteId){
                delete this.inviteId;
            }
        }

        changeStick(playerInfo) {
            this.table.stick.texture = this.assetManager.getTexture(this.getStick(playerInfo.stick).fileName);
        }

        changeTable(playerInfo) {
            let color = this.getFelt(playerInfo.felt).value;
            this.table.table.tint = color;

            this.table.centerSprite.tint = color;
            this.table.centerSprite.texture = this.assetManager.getTexture(this.getDecal(playerInfo.decal).fileName);
        }

        startSearchAnimation() {
            document.getElementById("searching").style.display = "flex";
            if (!this.searchTo) {
                this.searchTo = TweenMax.staggerFrom(".search",2,{x:0,backgroundColor:'#36edc9',opacity:0,scale:0.2,repeat:-1,ease:SlowMo.ease.config(0.5,0.4,true)},0.4);
            } else {
                this.searchTo.forEach(t => t.resume());
            }

            if (!this.searchFrom) {
                this.searchFrom = TweenMax.staggerTo(".search",2,{x:310,backgroundColor:'#43f9f3',repeat:-1,ease:SlowMo.ease.config(0.5,0.4,false)},0.4);
            } else {
                this.searchFrom.forEach(t => t.resume());
            }
        }

        stopSearchAnimation() {
            this.searchFrom.forEach(t => t.pause());
            this.searchTo.forEach(t => t.pause());
//        TweenMax.killTweensOf(this.searchIcons);
            document.getElementById("searching").style.display = "none";
        }

        refreshStats() {
            if (this.self.playerInfo && this.self.playerInfo.rank) {
                document.getElementById("winstatval").innerHTML = this.self.playerInfo.wins;
                document.getElementById("lossstatval").innerHTML = this.self.playerInfo.losses;
                document.getElementById("streakstatval").innerHTML = this.self.playerInfo.maxWinStreak;
                document.getElementById("foulstattval").innerHTML = this.self.playerInfo.fouls;
            }
        }

        refreshLoginScreen(){
            var loginContainer = document.getElementById("logincontainer");
            var loadingContainer = document.getElementById("loadingcontainer");
            var statsContainer = document.getElementById("playerstatcontainer");
            var loginButton = document.getElementById("login");
            var logoutButton = document.getElementById("logoutBtn");
            var googleButton = document.getElementById("googleBtn");
            var fbButton = document.getElementById("fbBtn");
            //document.getElementById("loginscreen").style.display = 'flex';
            //document.getElementById("login_name").focus();
            game.gui.matchDisplay.hide();

            if (!this.preloadCompleted) {
                loginContainer.style.display = "none";
                loadingContainer.style.display = "flex";
            } else if (!this.portalsocket || !this.portalsocket.connected) {
                game.gui.hideMainAll();
                game.menuBG.visible = false;
                game.table.showPanic();
            } else {

                //	loginContainer.style.display = "inline-block";

                loginButton.disabled = false;

                logoutButton.style.display = "none";
                googleButton.style.display = "none";
                fbButton.style.display = "none";

                var loginType = readCookie("logintype");
                if (!loginType || loginType == "") {
                    logoutButton.style.display = "none";
                    googleButton.style.display = "flex";
                    fbButton.style.display = "flex"
                    statsContainer.style.display = "none";
                } else if (loginType == "google") {
                    if (googleAuth2 && googleAuth2.isSignedIn.get()) {
                        logoutButton.style.display = "flex"
                        googleButton.style.display = "none"
                        fbButton.style.display = "none"
                        statsContainer.style.display = "flex";
                    } else {
                        logoutButton.style.display = "none"
                        googleButton.style.display = "flex"
                        fbButton.style.display = "flex";
                        statsContainer.style.display = "none";
                    }
                } else if (loginType == "fb") {
                    FB.getLoginStatus(function(response) {
                        if (response.status == 'connected') {
                            logoutButton.style.display = "flex";
                            googleButton.style.display = "none";
                            fbButton.style.display = "none";
                            statsContainer.style.display = "flex";
                        } else {
                            logoutButton.style.display = "none";
                            googleButton.style.display = "flex";
                            fbButton.style.display = "flex";
                            statsContainer.style.display = "none";
                        }
                    });
                }
                //   loginContainer.style.display = "flex";
                $('#logo-svg').fadeOut(500, () => {
                    loadingContainer.style.display = "none";
                    $("#main" ).fadeIn( "slow", () => {
                        loginButton.style.pointerEvents = "visible";
                    });
                    $("#leftmenu").fadeIn("slow");
                    $("#privacycontainer" ).fadeIn( "slow");
                    if (!readCookie("cookiesAccepted")) {
                        $("#kuki" ).fadeIn( "slow");
                    }
                    if (!game.menuBG.visible) {
                        game.menuBG.visible = true;
                        game.menuBG.alpha = 0;
                        game.menuFading = true;
                        game.table.hide();
                    }
                });
            }
        }

        processMouseInput(player, input) {
            var minDist = Config.mouseControlMinDist;
            var maxDist = Config.mouseControlMaxDist;
            var dir = input.sub(player.localState.pos);
            var dist = dir.length();
            if (dist <= minDist) {
                dir = new Coord(0,0);
            } else if (dist >= maxDist) {
                dir = dir.normal();
            } else {
                dir = dir.normal().mul_scalar((dist - minDist) / (maxDist - minDist));
            }

            return dir;
        }


        client_handle_input() {
            if (!this.client_logged_in) {
                return;
            }

            let chatMessageToSend = 0;
            let input = {};
            if (!this.client_typing) {
                if (this.keyboard.wasPressed('U') && !this.chatSystem.enabled) {
                    this.showDebug = !this.showDebug;
                    if (this.showDebug) {
                        this.debug_gui.domElement.style.display = "flex";
                    } else {
                        this.debug_gui.domElement.style.display = "none";
                    }
                }

                if (this.mouse.mouseDown || this.touchShoot) {
                    input.shot = true;
                }

                if (this.table.penaltyPos && this.touchPenalty) {
                    input.shot = true;
                }
            }
            this.touchPenalty = false;

            if (this.keyboard.wasPressed('enter')) {
                this.chatSystem.toggleChat();
            }

            let length = 1 + this.chatSystem.getMessagesLength();

            let mouse = this.mouse.getData();
            if (this.table.state == MatchStates.aim && this.shooter && mouse && !this.shotEnd) {
                if (input.shot && !this.prevInput.shot) {
                    this.table.shotStart(mouse.pos);
                } else if (input.shot && this.prevInput.shot) {
                    this.table.moveStick(mouse.pos);
                } else if (!input.shot && this.prevInput.shot && this.table.stickOffset) {
                    this.shotEnd = true;
                } else {
                    if (this.touchAim) {
                        let angle = mouse.pos.sub(this.table.white.position).angle();
                        while (angle - this.touchAim.prevAngle > Math.PI) {
                            angle -= Math.PI * 2;
                        }
                        while (angle - this.touchAim.prevAngle < -Math.PI) {
                            angle += Math.PI * 2;
                        }
                        this.touchAim.prevAngle = angle;
                        this.table.stickAngle = this.touchAim.stickStart + (angle - this.touchAim.touchStart) * 0.7;
                    } else if (!window.mobileAndTabletcheck()) {
                        this.table.aim(mouse.pos);
                    }
                }
            }

            length += 4 * 2;
            if (mouse) {
                input.mx = mouse.pos.x;
                input.my = mouse.pos.y;
                length += 4;
            }

            let arrayBuffer = new ArrayBuffer(length);
            let dataWriter = new DataWriter(arrayBuffer);

            dataWriter.writeFlags([
                mouse ? 1 : 0,
                input.shot,
                this.keyboard.wasPressed('K'),
                this.shotEnd
            ]);
            if (mouse) {
                dataWriter.writeInt16(input.mx);
                dataWriter.writeInt16(input.my);
            }
            dataWriter.writeFloat32(this.table.stickAngle);
            dataWriter.writeFloat32(this.table.stickOffset);

            this.mouse.resetWheel();

            this.chatSystem.serializeMessages(dataWriter);

            if (this.socket && this.socket.connected &&
                (!this.prevInput ||
                    this.keyboard.wasPressed('K') ||
                    this.prevInput.shot != input.shot ||
                    this.prevInput.mx != input.mx ||
                    this.prevInput.my != input.my ||
                    this.chatSystem.messages.length > 0))
            {
                this.prevInput = input;
                this.socket.emit('input', arrayBuffer);
            }

            this.chatSystem.clearMessages();
        }

        client_process_net_updates() {
            if (!this.server_updates)
                return;
            /*
		let target = this.server_updates;
		target.playerStates.forEach((v, i) => {
			let player = target.playerStates[i].player;
			if (!player)
				return;

			let state = target.playerStates[i];
			let targetState = target.playerStates[i].state;

			if (target.playerStates[i].jumped || player.jumped || player.hiddenPrev) {
				target.playerStates[i].jumped = false;
				player.jumped = false;
				player.localState = targetState.copy();
				return;
			}

			let dx = targetState.pos.x - player.localState.pos.x;
			let dy = targetState.pos.y - player.localState.pos.y;
			if (Math.abs(dx) > world.width / 2) {
				player.localState.pos.x += dx;
			}
			if (Math.abs(dy) > world.height / 2) {
				player.localState.pos.y += dy;
			}

			player.localState = player.localState.interpolate(targetState, Config.interpolationRate);
			player.rpm = lerp(player.rpm, state.rpm, Config.interpolationRate);
		});*/
        }

        readObject(objects, type, dataReader) {
            let obj = type.read(dataReader);
            if (!obj.id || !objects.find(o => o.id == obj.id)) {
                objects.push(obj);
            }
        }

        readObjects(objects, type, dataReader) {
            var objectNum = dataReader.readFloat32();
            for (let i = 0; i < objectNum; i++) {
                this.readObject(objects, type, dataReader);
            }
        }

        gameStateRecieved(buffer) {
            this.collectibles = [];

            let dataReader = new DataReader(buffer);
            this.readObjects(this.collectibles, Collectible, dataReader);
        }

        readEvent(dataReader) {
            let type = dataReader.readUint32();
            let event = this.eventTypes[type].read(dataReader);
            if (!event) {
                console.log("Unknown event type received.");
            }
            event.handle();
        }

        readMultiple(dataReader, reader) {
            var num = dataReader.readFloat32();
            for (let i = 0; i < num; i++) {
                reader(dataReader);
            }
        }

        readPlayerState(dataReader) {
        }

        client_onserverupdate_received(buffer) {
            let dataReader = new DataReader(buffer);

            let flags = dataReader.readFlags();
            let state = dataReader.readUint8();
            if (flags[0]) {
                this.table.penaltyPos = {
                    x: dataReader.readInt16(),
                    y: dataReader.readInt16()
                };
            } else {
                delete this.table.penaltyPos;
            }
            this.shooter = flags[1];
            this.setState(state);

            if (state != MatchStates.aim && !this.table.stickOffset) {
                this.shotEnd = false;
            }
            this.table.readStick = this.shotEnd || state != MatchStates.aim || !this.shooter;
            this.table.read(dataReader);
            this.readMultiple(dataReader, this.readEvent.bind(this));
        }

        client_create_ping_timer() {
            setInterval(function () {

                this.last_ping_time = Date.now() - this.fake_lag;
                if (this.socket && this.socket.connected)
                    this.socket.send('p.' + (this.last_ping_time));

            }.bind(this), 1000);
        }

        client_create_configuration() {
            this.show_help = false;             //Whether or not to draw the help text
            this.show_server_pos = false;       //Whether or not to show the server position
            this.show_dest_pos = false;         //Whether or not to show the interpolation goal
            this.input_seq = 0;                 //When predicting client inputs, we store the last input as a sequence number
            this.client_smooth = 0.01;            //amount of smoothing to apply to client update dest
            this.ball_smooth = 25;            //amount of smoothing to apply to client update dest

            this.net_latency = 0.001;           //the latency between the client and the server (ping/2)
            this.net_ping = 0.001;              //The round trip time from here to the server,and back
            this.last_ping_time = 0.001;        //The time we last sent a ping
            this.fake_lag = 0;                //If we are simulating lag, this applies only to the input client (not others)
            this.fake_lag_time = 0;

            this.net_offset = 1;              //100 ms latency between server and client interpolation for other clients
            this.buffer_size = 2;               //The size of the server history to keep for rewinding/interpolating.
            this.target_time = 0.01;            //the time where we want to be in the server onWatchTimeline
            this.oldest_tick = 0.01;            //the last time tick we have available in the buffer

            this.client_time = 0.01;            //Our local 'clock' based on server time - client interpolation(net_offset).
            this.server_time = 0.01;            //The time the server reported it was at, last we heard from it

            this.dt = 0.016;                    //The time that the last frame took to run
            this.fps = 0;                       //The current instantaneous fps (1/this.dt)
            this.fps_avg_count = 0;             //The number of samples we have taken for fps_avg
            this.fps_avg = 0;                   //The current average fps displayed in the debug UI
            this.fps_avg_acc = 0;               //The accumulation of the last avgcount fps samples

            this.lit = 0;
            this.llt = Date.now();
        }

        client_create_debug_gui() {
            this.debug_gui = new dat.GUI({ autoPlace: false });

            var _colorsettings = this.debug_gui.addFolder('Color appearance');
            var color_controller = _colorsettings.addColor(this, 'tableColor').listen();
            _colorsettings.open();


            color_controller.onChange((value) => {
                let color = game.tableColor[0];
                color = color << 8;
                color += game.tableColor[1];
                color = color << 8;
                color += game.tableColor[2];
                this.table.table.tint = color;
                this.table.centerSprite.tint = color;
                //console.log(value);
                // Fires on every change, drag, keypress, etc.
            });

            var brightness_controller = _colorsettings.add(this, 'tableBrightness',0,4).listen();
            brightness_controller.onChange((value) => {
                this.table.tableMatrix.brightness(value);
            });

            var _decalsettings = this.debug_gui.addFolder('Decal');
            let values = {};
            this.decals.forEach(d => values[d.itemName] = d.id);
            var decal_controller = _decalsettings.add(this, 'tableDecal', values).listen();
            _decalsettings.open();


            decal_controller.onChange((value) => {
                this.table.centerSprite.texture = game.assetManager.getTexture(game.getDecal(value).fileName);
            });

            /*
		var _othersettings = this.debug_gui.addFolder('Network smoohing');
		_othersettings.add(this, 'client_smooth').listen();
		_othersettings.add(this, 'ball_smooth').listen();

		var _debugsettings = this.debug_gui.addFolder('Debug view');
		_debugsettings.add(this, 'show_help').listen();
		_debugsettings.add(this, 'fps_avg').listen();
		_debugsettings.add(this, 'show_server_pos').listen();
		_debugsettings.add(this, 'show_dest_pos').listen();

		var _consettings = this.debug_gui.addFolder('Connection');
		_consettings.add(this, 'net_latency').step(0.001).listen();
		_consettings.add(this, 'net_ping').step(0.001).listen();
		//When adding fake lag, we need to tell the server about it.
		var lag_control = _consettings.add(this, 'fake_lag').step(0.001).listen();
		lag_control.onChange(function (value) {
			if (this.socket && this.socket.connected)
				this.socket.send('l.' + value);
		}.bind(this));

		var _netsettings = this.debug_gui.addFolder('Networking');
		_netsettings.add(this, 'net_offset').min(0.01).step(0.001).listen();
		_netsettings.add(this, 'server_time').step(0.001).listen();
        _netsettings.add(this, 'client_time').step(0.001).listen();
        */
            var customContainer = document.getElementById('my-gui-container');
            customContainer.appendChild(this.debug_gui.domElement);
            this.debug_gui.domElement.style.display = "none";
        }


        client_preload_files() {
            if (this.preloadCompleted) {
                this.client_preload_completed();
                return;
            }

            this.preloadTimeLine = new TimelineMax({
                repeat: -1
            });

            this.preloadTimeLine.add(
                TweenMax.from(".logo-svg", 2, {
                    scale: 2,
                    rotation: 360,
                    ease: Elastic.easeInOut

                })
            );
            document.getElementById("logo-svg").style.display = "flex";

            this.preloadTimeLine.add(
                TweenMax.to(".logo-svg", 2, {
                    scale: 2,
                    rotation: 360,
                    ease: Elastic.easeInOut

                })
            );

            this.assetManager.preloadAssets(this.client_preload_completed.bind(this));
            /*		for (let i = 1; i <= this.soundPlayer.maxTrack; ++i) {
			let soundId = 'music'+i;
			let url = '\\music\\'+soundId+'.mp3';
			var mySound = soundManager.createSound({
				id: soundId,
				url: url
			});
		}*/
        }

        client_preload_completed() {
            this.preloadCompleted = true;
            var userName = readCookie("userName");
            if (userName && userName.length) {
                document.getElementById("login_name").value = userName;
            }
            let badwords = JSON.parse(this.assetManager.getText("words.json"));
            let badwordsStr = badwords.words.join("|");
            this.regexp = new RegExp(badwordsStr, 'ig');

            this.initGame();
            let logo = document.getElementById('logo-svg');
            TweenMax.killTweensOf(logo);
            this.searchIcons = [];
            this.searchIcons.push(document.getElementById('s1'));
            this.searchIcons.push(document.getElementById('s2'));
            this.searchIcons.push(document.getElementById('s3'));
            this.searchIcons.push(document.getElementById('s4'));
            this.searchIcons.push(document.getElementById('s5'));

            this.gui.selectLeftMenuItem(0);
            this.refreshLoginScreen();
        }

        client_ondisconnect(column) {
            this.self.online = false;
            this.self.alive = false;
            this.client_logged_in = false;

            //this.gui.respawnScreen.hide();
            this.refreshLoginScreen();
            this.players = [];
            if (this.socket) {
                if (this.socket.connected)
                    this.socket.disconnect();
                delete this.socket;
                this.players = [];
            }
//		document.getElementById("chatcontainer").style.display = 'none';
        }

        client_onping(column) {
            this.net_ping = Date.now() - parseFloat(column);
            this.net_latency = this.net_ping / 2;
        }

        client_onnetmessage(column) {
            var commands = column.split('.', 3);
            var command = commands[0];
            var subcommand = commands[1] || null;
            var commanddata = commands[2] || null;
            switch (command) {
                case 's': //server message
                    switch (subcommand) {
                        case 'e': //end game requested
                            this.client_ondisconnect(commanddata); break;
                        case 'p': //server ping
                            this.client_onping(commanddata); break;
                    } //subcommand
                    break; //'s'
            } //command
        }

        client_connect_to_portal() {
            this.portalsocket = io.connect();
            this.portalsocket.on('onConnectedPortal', this.client_onConnectedPortal.bind(this));
            this.portalsocket.on('disconnect', this.client_ondisconnect.bind(this));
            this.portalsocket.on('itemsUpdated', this.client_itemsUpdated.bind(this));
            this.portalsocket.on('globalInfoResp', this.client_globalInfoResp.bind(this));
            this.portalsocket.on('inviteResp', this.client_inviteResp.bind(this));
            this.portalsocket.on('sysMessages', this.client_sysMessages.bind(this));
            this.portalsocket.on('announcement', this.client_announcement.bind(this));
            this.portalsocket.on('selfInfo', this.client_selfInfo.bind(this));
            this.portalsocket.on('itemReceived', this.client_itemReceived.bind(this));
            this.portalsocket.on('inventory', this.client_inventory.bind(this));


            this.portalsocket.on('loginSuccess', this.client_loginSuccess.bind(this));
            this.portalsocket.on('logoutFinished', this.client_logoutFinished.bind(this));
            this.portalsocket.on('loginFailed', this.client_loginFailed.bind(this));
            this.portalsocket.on('enterSuccess', this.client_enterSuccess.bind(this));
            this.portalsocket.on('matchStarted', this.client_matchStarted.bind(this));

            this.portalsocket.on('alert', this.client_alert.bind(this));

        }

        client_sysMessages(messages) {
            messages.forEach(m => {
                game.chatSystem.addSystemMessage(m);
            });
        }

        client_announcement(message) {
            game.chatSystem.addAnnouncement(message);
        }

        client_selfInfo(column) {
            game.self.playerInfo = column;
            game.customizer.playerInfoUpdated();
            this.gui.inventoryScreen.setup();
        }

        client_inventory(column) {
            game.inventory = column;
            game.customizer.playerInfoUpdated();
            this.gui.inventoryScreen.setup();
        }

        client_itemReceived(column) {
            let item = this.items.find(i => i.itemGuid == column);
            if (item) {
                this.gui.notificator.itemReceived(item);
            }
        }

        client_connect_to_server(addr) {
            if (this.socket) {
                if (this.socket.connected)
                    this.socket.disconnect();
                delete this.socket;
                this.players = [];
            }
            this.socket = io.connect("wss://"+addr, {transports:['websocket', 'polling'], httpCompression:false, perMessageDeflate:false});
            this.socket.on('connect', function () {
                this.self.state = 'connecting';
            }.bind(this));
            //this.socket.on('disconnect', this.client_ondisconnect.bind(this));
            this.socket.on('onserverupdate', this.client_onserverupdate_received.bind(this));
            this.socket.on('gamestate', this.gameStateRecieved.bind(this));
            this.socket.on('onconnected', this.client_onconnected.bind(this));
            //this.socket.on('error', this.client_ondisconnect.bind(this));
            this.socket.on('message', this.client_onnetmessage.bind(this));
            this.socket.on('alert', this.client_alert.bind(this));
        }

        client_onConnectedPortal(infos) {
            this.guestInventory = infos.guestInventory;
            this.soundEngine = new SoundEngine();
            this.assetManager = new AssetManager(infos.assetFiles, this.soundEngine);

            this.region = infos.region;
            this.country = infos.country;
            if (!infos.country) {
                this.country = "us";
            }
            this.serverInfos = infos.serverList;

            var serverlist = document.getElementById('serverlist');
            for(var i = serverlist.options.length - 1 ; i >= 0 ; --i)
                serverlist.remove(i);
            var selectOption = document.createElement("Option");
            selectOption.text = 'Select a server';
            selectOption.disabled = true;
            if (infos.serverList.length == 0)
                selectOption.selected = true;
            serverlist.add(selectOption);

            infos.serverList.forEach(serverInfo => {
                var option = document.createElement("option");
                option.text = serverInfo.nickname + " [" + serverInfo.players + "/" + serverInfo.maxPlayers + "]";
                option.value = serverInfo.address;
                serverlist.add(option);
                if (serverInfo.preferred) {
                    option.selected = true;
                }
            });

            this.top10 = infos.top10;
            this.leaderboard = [];
            this.client_preload_files();

            this.updateItems(infos.items);
        }


        client_itemsUpdated(items) {
            this.updateItems(items);
        }

        client_globalInfoResp(column) {
            if (this.globalInfoRespFunc) {
                this.globalInfoRespFunc(column);
            }
        }

        client_inviteResp(inviteId) {
            this.inviteId = inviteId;
            this.gui.setupInviteScreen(inviteId);
        }

        client_matchStarted(column) {
            this.startingMatchData = column;
            this.client_connect_to_server(column.address);
        }


        client_onconnected(column) {
            this.self.clientId = column.clientId;
            this.self.state = 'connected';
            this.self.online = true;
            if (this.startingMatchData) {
                let column = {
                    matchId: this.startingMatchData.matchId,
                    sessionId: this.sessionId
                }
                this.socket.emit('joinMatch', column);
                delete this.startingMatchData;
            }
        }


        client_refresh_fps() {
            this.fps = 1 / this.dt;
            this.fps_avg_acc += this.fps;
            this.fps_avg_count++;
            //When we reach 10 frames we work out the average fps
            if (this.fps_avg_count >= 10) {
                this.fps_avg = this.fps_avg_acc / 10;
                this.fps_avg_count = 1;
                this.fps_avg_acc = this.fps;
                this.fpsText.text = this.fps_avg;
            } //reached 10 frames
        }

        updateItems(items) {
            this.items = items;
            this.items.forEach(item => {
                switch (item.type) {
                    case "stick": item.filter = InventoryFilter.Stick; break;
                    case "avatar": item.filter = InventoryFilter.Avatar; break;
                    case "decal": item.filter = InventoryFilter.Decal; break;
                    case "goalie": item.filter = InventoryFilter.Goalie; break;
                    default: item.filter = InventoryFilter.Misc; break;
                }
            });
        }

        updateInfoCanvas() {
            if (!this.infoCanvas) {
                return;
            }

            var context = this.infoCanvas.getContext('2d');

            context.clearRect(0,0,this.infoCanvas.width, this.infoCanvas.height);

            context.save();
            context.textBaseline="top";
            context.fillStyle = 'rgba(18,47,54,1.0)';
            context.fillText(this.net_ping + ' ms', 0, 0);
            context.fillText(this.fps.toFixed(0) + ' fps', 0, 10);
            context.restore();
        }


        createLeaderboardRow(placement, playerInfo, self, placementId) {
            let row = document.createElement("div");
            if (self) {
                row.className = "leaderboardrowself";
            } else {
                row.className = "leaderboardrow";
            }

            let place = document.createElement("div");
            if (self) {
                place.className = "top10placeself";
            } else {
                place.className = "top10place";
            }
            if (placementId) {
                place.id = placementId;
            }
            place.innerHTML = ordinalSuffix(placement);
            row.appendChild(place);

            let nickname = document.createElement("div");
            nickname.className = "top10name";
            nickname.innerHTML = censore(playerInfo.userName,game.regexp);

            row.appendChild(nickname);

            let score = document.createElement("div");
            score.className = "top10score";
            score.innerHTML = playerInfo.score;
            row.appendChild(score);

            let rank = document.createElement("div");
            rank.className = "top10rank";
            if (!self) {
                rank.style.color = getRankColor(playerInfo.rank);
            }
            rank.innerHTML = RankType[playerInfo.rank].nickname;
            row.appendChild(rank);

            let playtime = document.createElement("div");
            playtime.className = "top10playtime";
            playtime.innerHTML = millisToPlayTime(playerInfo.playTime);
            row.appendChild(playtime);

            return row;
        }

        requestGlobalInfo(guid, globalInfoRespFunc) {
            game.globalInfoRespFunc = globalInfoRespFunc;
            game.portalsocket.emit('globalInfoReq', guid);
        }

        initTop10List() {
            let list = document.getElementById("top10list");
            list.innerHTML = "";
            let wasSelf = false;
            game.top10.forEach((playerInfo, i) => {
                let self = game.self.playerInfo && playerInfo.guid == game.self.playerInfo.guid;
                if (self) {
                    wasSelf = true;
                }
                let row = this.createLeaderboardRow(i+1, playerInfo, self);
                list.appendChild(row);
            });


            if (game.self.playerInfo && game.self.playerInfo.rank && !wasSelf) {
                let row = this.createLeaderboardRow(127, game.self.playerInfo, true, "placement");
                list.appendChild(row);
                row.style.marginTop = "10px";
                game.requestGlobalInfo(game.self.playerInfo.guid,  (column) => {
                    document.getElementById("placement").innerHTML = ordinalSuffix(column.globalPlacement);
                });
            } else if (game.self.playerInfo && game.self.playerInfo.rank == 0)  {
                let row = document.createElement("div");
                row.className = "leaderboardrowself";
                row.innerHTML = "Please sign-in to get placement!"
                row.style.marginTop = "10px";
                row.style.justifyContent = "center";
                list.appendChild(row);
            }
        }

        initHpBars() {
            this.hpBars = [];
            this.hpBars.push([]);
            this.hpBars.push([]);

            for (let j = 0; j<2; ++j) {
                for (let i = 1; i <= 7; ++i) {
                    let hpBar = document.getElementById('player'+(j+1)+'hp'+i);
                    hpBar.style.opacity = "1";
                    this.hpBars[j].push(hpBar);
                }
            }
        }

        setHpBars() {
            this.playerStates.forEach((p,i) => {
                let hp = p.hp;
                for (let j = 0; j < 7; ++j) {
                    if (j <= hp-1) {
                        this.hpBars[i][j].style.opacity = "1";
                    } else {
                        this.hpBars[i][j].style.opacity = "0.5";
                    }
                }
            });
        }

        initScoreBars() {
            this.scoreBars = [];
            this.scoreBars.push([]);
            this.scoreBars.push([]);

            for (let j = 0; j < 2; ++j) {
                for (let i = 1; i <= 2; ++i) {
                    let scoreBar = document.getElementById('player'+(j+1)+'score'+i);
                    this.scoreBars[j].push(scoreBar);
                }
            }
        }

        setScoreBars() {
            this.playerStates.forEach((p,i) => {
                let score = p.score;
                for (let j = 0; j < 2; ++j) {
                    if (j <= score-1) {
                        $("#"+this.scoreBars[i][j].id).addClass("playerscore");
                        $("#"+this.scoreBars[i][j].id).removeClass("playerscoregrey");
                        this.scoreBars[i][j].style.backgroundColor = this.getColor(this.playerInfos[i].color).text;
                    } else {
                        $("#"+this.scoreBars[i][j].id).removeClass("playerscore");
                        $("#"+this.scoreBars[i][j].id).addClass("playerscoregrey");
                        this.scoreBars[i][j].style.backgroundColor = "#2d899d";
                    }
                }
            });
        }

        recolorAll() {
            let color1 = this.getColor(this.playerInfos[0].color);
            let color2 = this.getColor(this.playerInfos[1].color);
            this.table.colorBalls(0, color1.value);
            this.table.colorBalls(1, color2.value);
            for (let i = 1; i <= 7; ++i) {
                document.getElementById('player1hp'+i).style.backgroundColor = color1.text;
                document.getElementById('player2hp'+i).style.backgroundColor = color2.text;
                document.getElementById('player1username').style.color = color1.text;
                document.getElementById('player2username').style.color = color2.text;

            }
            this.table.goalLeft.tint = color1.value;
            this.table.goalRight.tint = color2.value;
        }

        getInviteLink() {
            this.portalsocket.emit('inviteRequest');
        }
    }


//server side we set the 'game_core' class to a global type, so that it can use it anywhere.
    if ('undefined' != typeof global) {
        global.game_core = game_core;
        global.Coord = Coord;
        global.RankType = RankType;
        global.Config = Config;
        global.Player = Player;
        global.PlayerInfo = PlayerInfo;
        global.Table = Table;
        global.MatchEvent = MatchEvent;
        global.MatchEventTypes = MatchEventTypes;
        global.UserPriviliges = UserPriviliges;
        global.DataReader = DataReader;
        global.DataWriter = DataWriter;
        global.getAngleDiff = getAngleDiff;
        global.createArray2D = createArray2D;
        global.Ball = Ball;
        global.MatchStates = MatchStates;
        module.exports = { MatchStates, Ball, createArray2D, getAngleDiff, DataReader, DataWriter, Player, PlayerInfo, Table, MatchEvent, MatchEventTypes, Config, game_core, Coord, RankType, UserPriviliges };
    }


// client

    function fbLogin(){
        createCookie("logintype", "fb");
        game.client_loginAttempt();
    }

    function googleLogin(googleToken){
        createCookie("logintype", "google");
        game.client_loginAttempt();
    }

    function logout(){
        game.client_logout();
    }

    function handleFBLogin(){
        FB.login(function(response) {
            if (response.status == 'connected')
                fbLogin();
            else
                window.alert('Facebook login failed.');
        }, {scope: 'email,public_profile'});
    }

    function handleGoogleLogin(){
        googleAuth2.signIn().then( res => {
            googleLogin();
        });
    }

    window.onLoadGAPI = function(){
        gapi.load('auth2', function(){
            gapi.auth2.init({
                client_id: '307542460385-84ssgnvnpe8t92pok3qsednm8i4cmqnp.apps.googleusercontent.com'
            }).then(() =>  {
                googleAuth2 = gapi.auth2.getAuthInstance();
                game.client_loginAttempt();
            });
        });
    }

    var animationFrames = [];
    function loadAnimationFrames(resources, renderer) {
        for (let resource in resources) {
            if (resource.startsWith('assets/images/effects') && resource.endsWith('json')) {
                let column = resources[resource].column;
                for (let path in column.frames) {
                    let parts = path.split('/');
                    let nickname = parts[0];
                    let index = parts[1].substring(nickname.length + 1, nickname.length + 1 + 2);
                    if (!animationFrames[nickname]) {
                        animationFrames[nickname] = [];
                    }
                    animationFrames[nickname].push({ frame: column.frames[path], index: index, path: path });
                }
            }
        }
        for (let nickname in animationFrames) {
            let frames = animationFrames[nickname];
            frames.sort((a, b) => a.index - b.index);
            frames.forEach((frame, i) => {
                frames[i] = PIXI.Texture.fromFrame(frame.path);
                // renderer.plugins.prepare.upload(frames[i]);
            });
            console.log("Animation nickname: " + nickname + ", Length: " + frames.length);
        }
    }

    window.onload = function() {
        $(document).ready(function(){
            $(document).keydown(function(event) {
                if (event.ctrlKey==true && (event.which == '61' || event.which == '107' || event.which == '173' || event.which == '109'  || event.which == '187'  || event.which == '189'  ) ) {
                    event.preventDefault();
                }
            });

            $(window).bind('mousewheel DOMMouseScroll', function (event) {
                if (event.ctrlKey == true) {
                    event.preventDefault();
                }
            });
        });

        createGameCore();
    }

    function createGameCore() {
        game = new game_core_client();

        window.mobileAndTabletcheck = function() {
            var check = false;
            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
            return check;
        };

        //Make this only if requested
        // if (String(window.location).indexOf('debug') != -1) {
        // 	game.client_create_debug_gui();
        // }

    };

};

var frame_time = 60 / 1000;
var UUID;

var SERVER = 'undefined' != typeof (global);
if (SERVER) {
    frame_time = 45;
    UUID = require('node-uuid');
    main();
} else {
    var hidden, visibilityChange;
    if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support
        hidden = "hidden";
        visibilityChange = "visibilitychange";
    } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange";
    } else if (typeof document.webkitHidden !== "undefined") {
        hidden = "webkitHidden";
        visibilityChange = "webkitvisibilitychange";
    }

    require([
        "lib/Stats.js"
    ], main);
}