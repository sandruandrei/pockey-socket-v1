<!DOCTYPE html>
<!-- saved from url=(0042)https://s.codepen.io/kidComet/debug/aKRXNp -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://static.codepen.io/assets/favicon/favicon-8ea04875e70c4b0bb41da869e81236e54394d63638a1ef12fa558a4a835f1164.ico">
  <link rel="mask-icon" type="" href="https://static.codepen.io/assets/favicon/logo-pin-f2d2b6d2c61838f7e76325261b7195c27224080bc099486ddd6dccb469b8e8e6.svg" color="#111">
  <title>CodePen - Starcade Preloader6</title>
  

      <style>
      body {
	margin: 0;
	padding: 0;
  background: radial-gradient(at bottom center, #60f9ff 10%, #42fff8 30%, #167692 55%, #1d0f22 90%);
  overflow: hidden;
}
    </style>
  

</head>

<!--<body translate="no">-->


<canvas id="canvas" width="626" height="734"></canvas>

      <script>
      //Frame setup - Twist / Grim / Zanz / kidComet
  //Don't worry about the frame stuff. The main frame stuff you'll need to use are:
  //FRAME.scaleY and FRAME.scaleX. It's essentially the scaling in here. Often something like
  //(FRAME.y - window.innerHeight/2)/FRAME.scaleY;
  //If you're gonna add stuff, make sure it scales somehow with FRAME. 
var FRAME = {ctx:null, canvas:null, game_width:0, game_height:0, scaleX:1, scaleY:1, x:0, y:0, images: new Map()};
FRAME.resize = function() {
	var stageWidth = window.innerWidth;
	var stageHeight = window.innerHeight;
	
	var ratio = stageWidth / stageHeight;
	
	if (ratio > FRAME.game_width / FRAME.game_height) {
		FRAME.scaleY = FRAME.scaleX = stageHeight / FRAME.game_height;
	}
	else {
		FRAME.scaleX = FRAME.scaleY = stageWidth / FRAME.game_width;
	}
	if (stageWidth > 1000) FRAME.scaleX = FRAME.scaleY;
	
	FRAME.canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
	FRAME.canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
}
FRAME.init = function(w, h, canvas) {
	FRAME.game_width = w;
	FRAME.game_height = h;
	FRAME.canvas = canvas;
	FRAME.ctx = canvas.getContext("2d");
	
	window.addEventListener( 'resize', FRAME.resize, false );
	FRAME.resize();
}
FRAME.clearScreen = function() {
	FRAME.ctx.setTransform(FRAME.scaleX, 0, 0, FRAME.scaleY, FRAME.x, FRAME.y);
	FRAME.ctx.clearRect(-FRAME.x / FRAME.scaleX, -FRAME.y / FRAME.scaleY, window.innerWidth / FRAME.scaleX, window.innerHeight / FRAME.scaleY);
}
FRAME.loadImage = function(path, name) {
	var img = new Image();
	img.src = path;
	img.key = name;
	FRAME.images.set(name, img);
}
FRAME.getImage = function(name) {
	return FRAME.images.get(name);
}

requestFrame = ( window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||
	window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
	function( callback ) {
		window.setTimeout(callback, 1000 / 30);
	});
	//FRAME STUFF ENDS

//The Actor class is the general none-image class you'll use if you want to add new elements to the scene. 
//So you'll do class MyElement extends Actor()
//Your new class will need a constructor function, a render function, and a draw function. 
//You'll have to call all of these functions I.E MyElement.draw at the end of the script. I'll comment that portion too. 
class Actor {
  //The function that essentially creates the base for the element
	constructor(x, y, rot, ctx) {
		this.age = 0;
		this.ctx = ctx || FRAME.ctx;
		this.x = x || 0;
		this.y = y || 0;
		this.rotation = rot || 0.0;
	}
  //Render is where actual paths and stuff are rendered. Put all of your actual art/elements in here. 
	render() {}
  
  //You don't add draw to your function, instead you just call it elsewhere. 
	draw() {
		this.ctx.translate(this.x, this.y);
		this.ctx.rotate(this.rotation);
		this.render();
		this.ctx.rotate(-this.rotation);
		this.ctx.translate(-this.x, -this.y);
	}
  //YOU DO want to add update in your function. Call update for things that need to change every frame. So animation/incremental variables would be defined here. 
	update(deltaTime) {
		this.age += deltaTime;
	}
}

//Same as Actor, but for images/svgs
class ImageActor extends Actor {
	constructor(x, y, img, size=1) {
		super(x, y);
		
		this.image = img;
		this.width = this.image.width * size;
		this.height = this.image.height * size;
	}
	render() {
		this.ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height);
	}
}

//Not 100% sure to be honest. Haven't needed it. It's used for stars though. 
class Collection {
	constructor(ctx) {
		this.objects = [];
		this.x = 0;
		this.y = 0;
		this.rotation = 0;
		this.ctx = ctx || FRAME.ctx;
	}
	add(obj) {
		this.objects.push(obj);
	}
	remove(obj) {
		var index = this.objects.indexOf(obj);
		if (index != -1) {
			this.objects.splice(index, 1);
		}
	}
	clear() {
		this.objects.splice(0, this.objects.length);
	}
	update(deltaTime) {
		for (var i = 0; i < this.objects.length; i++) {
			this.objects[i].update(deltaTime);
			if (this.objects[i].dead !== undefined && this.objects[i].dead === true) {
				this.remove(this.objects[i]);
				i--;
			}
		}
	}
	draw() {
		for (var i = 0; i < this.objects.length; i++) {
			this.ctx.translate(this.x, this.y);
			this.ctx.rotate(this.rotation);
				this.objects[i].draw();
			this.ctx.rotate(-this.rotation);
			this.ctx.translate(-this.x, -this.y);
		}
	}
}

//Used for the text. Pretty self explanitory 
class Text {
	constructor(x, y, text, font, fillStyle, fontsize, justify, rot, ctx) {
		this.x = x || 0;
		this.y = y || 0;
		this.text = text || "";
		this.font = font || "Arial";
		this.fillStyle = fillStyle || "#333";
		this.fontsize = fontsize || 30;
		this.justify = justify || "left";
		this.rotation = rot || 0;
		this.ctx = ctx || FRAME.ctx;
		
		this.ctx.font = this.fontsize + "px " + this.font;
		this.width = this.ctx.measureText(this.text).width;
		
		this.update = function(deltaTime) {}
		this.render = function() {}
		this.draw = function() {
			this.ctx.translate(this.x, this.y);
			this.ctx.rotate(this.rotation);
				this.ctx.font = this.fontsize + "px " + this.font;
				this.ctx.fillStyle = this.fillStyle;
				this.width = this.ctx.measureText(this.text).width;
				this.render();//whatever extra stuff
				if (this.justify == "left") {
					this.ctx.fillText(this.text, 0, this.fontsize);
				}
				else if (this.justify == "right") {
					this.ctx.fillText(this.text, -this.width, this.fontsize);
				}
				else {
					this.ctx.fillText(this.text, -this.width / 2, this.fontsize);
				}
			this.ctx.rotate(-this.rotation);
			this.ctx.translate(-this.x, -this.y);
		}
	}
}

//Loading screen stuff
//This is how you load images. First is the link, then the name you want to give the link. 
FRAME.loadImage("https://s3.amazonaws.com/starcade/full_star.svg", "logo");
FRAME.loadImage("http://zackseliger.com/starcade_preloader/star-cross.svg", "star");
  
//constants that you might find helpful
var MAX_STAR_SIZE = 4;
var STAR_COUNT = 600;
var STAR_TWINKLE_AMOUNT = .6;
var SUN_RADIUS = 150;
var LOADING_BAR_WIDTH = 500;
var NUM_BARS = 7;
var CORONA_START_SIZE = 30;
var CORONA_FINAL_SIZE = 50;
//the one and only...
var loadingProgress = 0;

//global functions
//These are the functions that will update progress
function addLoadingProgress(amt) {
	loadingProgress += amt;
}
function getLoadingProgress() {
	return loadingProgress;
}
function setLoadingProgress(a) {
	loadingProgress = a;
}
function isGameReady() {
	return loadingProgress>=1;
}

//The horizon
  class MountainBottom extends Actor {
    constructor() {
      super(); //super() is REQUIRED in the constructor. Without it, nothing will work. Always add it. **Parallax??? 
      //settings
      this.glowSize = 70;
      
      //inner glow gradient
      this.grdInner = this.ctx.createRadialGradient(0, 0, 200, 0, 0, SUN_RADIUS);
	  this.grdInner.addColorStop(0, 'rgb(255, 255, 255,1)');
      this.grdInner.addColorStop(0.05, 'rgb(100, 255, 255,1)');	
      this.grdInner.addColorStop(0.3, 'rgb(50, 200, 255,0.4)');
      this.grdInner.addColorStop(0.65, 'rgb(60, 170, 215,0.10)');
      this.grdInner.addColorStop(1, 'rgb(0, 0, 0,0)');
      
      //outer glow gradient
      this.grdOuter = this.ctx.createRadialGradient(3, 5, 210+this.glowSize, 3, 3, 0);
      this.grdOuter.addColorStop(0, 'rgb(255,  85, 255, 0.0)');    
      this.grdOuter.addColorStop(0.5, 'rgb( 94, 242, 255, 0.7)');
      this.grdOuter.addColorStop(0.4, 'rgb( 94, 242, 255, 0.6)');
      }
    update() {
     // this.x = (-FRAME.x + window.innerWidth/2)/FRAME.scaleX;    
      //this.y = (-FRAME.y + window.innerHeight)/FRAME.scaleY;///2 - (-window.innerHeight/1.5 - 50);
      this.x = (-FRAME.x + window.innerWidth/2)/FRAME.scaleX;
      this.y = (-FRAME.y + window.innerHeight/2)/FRAME.scaleY + 620;
    }
    render() {

       //Since we're modifying the scale and shit, I have to save the current ctx, so I can modify shit, and then restore the ctx the way it was before I fucked it all up. 
      this.ctx.save();
      this.ctx.scale((window.innerWidth/720)/FRAME.scaleX * 3.5, 2.5) ;
      
  //outer glow
    this.ctx.fillStyle = this.grdOuter;
    this.ctx.beginPath();
    this.ctx.arc(0,2,250+this.glowSize,0,1*Math.PI,true);
    this.ctx.fill();
    this.ctx.closePath();
      
      //The inside of the horizon 
      this.ctx.beginPath();
      this.ctx.fillStyle = " #0d171c";
      this.ctx.arc(0,1, 199, 25, 2*Math.PI, true);
      this.ctx.fill();
      this.ctx.closePath();
    
      //drawing inner glow
      this.ctx.fillStyle = this.grdInner;
      this.ctx.beginPath();
      this.ctx.arc(0,0,200,0,1*Math.PI,true);
      this.ctx.fill();
      this.ctx.closePath();

      this.ctx.restore() ;
    }
}

//The moving lines. 
class Line extends Actor {
	constructor() {
		super(0,SUN_RADIUS);
		this.topWidth = 0;
		this.bottomWidth = 0;
		this.height = 20;
		this.speed = 1;
	}
	update() {
		//decrease speed, height, and y position
		this.y -= this.speed;
		this.height -= 0.045;
		this.speed += (0 - this.speed) * 0.001;
		if (this.y < -SUN_RADIUS) this.dead = true;//this.dead is a thing in the Collection class...
		
		//top and bottom of line has to have different widths
		this.topWidth = 2*Math.sqrt(Math.pow(SUN_RADIUS,2) - Math.pow(this.y-this.height/2,2));
		this.bottomWidth = 2*Math.sqrt(Math.pow(SUN_RADIUS,2) - Math.pow(this.y+this.height/2,2));
	}
	render() {
		this.ctx.fillStyle = "#000";
    
		this.ctx.beginPath();
		this.ctx.moveTo(-this.topWidth/2, -this.height/2);
		this.ctx.lineTo(this.topWidth/2, -this.height/2);
		this.ctx.lineTo(this.bottomWidth/2, this.height/2);
		this.ctx.lineTo(-this.bottomWidth/2, this.height/2);
    this.ctx.closePath();
  
		this.ctx.fill();
	}
}

//Logo in the center. Another image. 
class Logo extends ImageActor {
  constructor(){
    super(0,0.,FRAME.getImage("logo"));
    this.width *= 0.72; //Change these to change how the logo scales
    this.height *= 0.72;
  }
  
  update(){
    this.ctx.x = (-FRAME.x + window.innerWidth/2)/FRAME.scaleX - 145; //These control the location of the logo. If you want to change
    this.ctx.y = (-FRAME.y + window.innerHeight/2)/FRAME.scaleY - 150; //position, just change the numbers (143 and 150)
  }
  render() {
    this.ctx.drawImage(this.image, this.ctx.x, this.ctx.y,this.width,this.height);
  }
}

//The back of the logo 
class Sun extends Actor {
	constructor() {
		super();
		this.rad = 0; //No touchy
		this.lines = new Collection(); //Still no touchy
		this.linesTimer = 0;
		
		this.cycler = 0.0;
		
		this.gradient = this.ctx.createLinearGradient(30,-SUN_RADIUS,30,SUN_RADIUS);
		this.gradient.addColorStop(0.2,"rgb(252, 243, 190)");//These are the sun colors.
		this.gradient.addColorStop(0.8,"rgb(178, 49, 133)"); //I got them pretty close, so... 
		this.gradient.addColorStop(0.9,"rgb(255, 0, 127)");
	}
	update() {
		this.x = (-FRAME.x + window.innerWidth/2)/FRAME.scaleX; //The location. Try not to touch it unless you have to. You'll have to move 
		this.y = (-FRAME.y + window.innerHeight/2)/FRAME.scaleY; //A LOT of stuff around if you do.
		this.lines.update(); //The lines get updated from WITHIN this class
		this.rad += (SUN_RADIUS - this.rad) * 0.2; //Radius
		
		//harmonic motion
		this.cycler += 0.08;
		
		//countdown to add new line
		this.linesTimer -= 1;
		if (this.linesTimer < 0) {
			this.linesTimer = 50;
			this.lines.add(new Line());
		}
	}
	render() {
    for(var i = 0; i<5; i++) {
      this.ctx.fillStyle = "rgba(50, 230, 250, 0.2)";
      this.ctx.beginPath();
      this.ctx.arc(0,0,this.rad+(i+.4)*((1.5-loadingProgress)*CORONA_START_SIZE+loadingProgress*CORONA_FINAL_SIZE)+Math.sin(i/2-this.cycler)*5,0,2*Math.PI);
      this.ctx.fill();
    }
    
		//actual sun
		this.ctx.fillStyle = this.gradient;
		this.ctx.beginPath();
		this.ctx.arc(0,0,this.rad,0,2*Math.PI);
		this.ctx.fill();
    
    // black border
    this.ctx.strokeStyle="rgb(0, 0, 0)";
    this.ctx.lineWidth=5;
    this.ctx.stroke();
    
    //lines
		this.lines.draw(); //Drawing the lines
	}
}

//The loading bar. Shocking, right? 
class LoadingBar extends Actor {
	constructor() {
		super();
		this.progress = 0;//we tween this value to actual loading progress so it looks nice
		this.loadingText = new Text(0,200,"LOADING 0%","Denk One","#00ffd5",27,"center");//x, y, text, font family...
	  this.timerCountdown = 0; //We initialize the timer countdown at 0 when we initialize the bar 
		//harmonic motion arrays
		this.extras = [];
		this.cyclers = [];
    this.flavorText = ["CONSTRUCTING ADDITIONAL PYLONS ", 
                       "PLAYER ONE NOT READY ", 
                       "PIXELLATING REAL LIFE ", 
                       "DOWNLOADING MORE RAM ",
                       "PETTING CATS ", 
                       "WHAT WAS I DOING? OH RIGHT ", 
                       "HAVING AN EXISTENTIAL CRISIS "]; 
    
    //THIS! This is the array that holds the flavor text. Add to it freely. 
    this.text = Math.floor(Math.random() * this.flavorText.length); 
    
    //Initialize this.text (which is used for the array)
		for (var i = 0; i < NUM_BARS; i++) {
			this.extras.push(0);
			this.cyclers.push(i*2.2);
		}
	}
	update() {
    this.timerCountdown++; //Add one to the timer
   
		this.x = (-FRAME.x + window.innerWidth/2)/FRAME.scaleX;
		this.y = (-FRAME.y + window.innerHeight/2)/FRAME.scaleY + 190; //You know what this is by now
		
		//harmonic motion for bars
		for (var i = 0; i < NUM_BARS; i++) {
			this.cyclers[i] -= 0.11;
			this.extras[i] = Math.sin(this.cyclers[i])/100;
		}
		
		//lerp progress variable closer to actual progress
    if (this.timerCountdown == 110 && this.progress < .99){ //Check that the 110  updates have passed since last text change, and that we're under 99% done
      this.text = Math.floor(Math.random() * this.flavorText.length);
      this.timerCountdown = 0;
      
    } else if(this.progress > .99) {
      this.flavorText[0] = "LOADING COMPLETE! ";
      this.text = 0;
    }
    
		this.progress += (loadingProgress - this.progress) * 0.01;
		if (Math.abs(this.progress - loadingProgress) < 0.0025) {
			this.progress = loadingProgress;
    }
		this.loadingText.text = this.flavorText[this.text] + Math.floor(this.progress*100) + "%";
	}
	render() {
		this.loadingText.draw();
		this.ctx.lineCap = "round";
    
    this.ctx.save();
    this.ctx.scale((window.innerWidth/720)/FRAME.scaleX * 3.5, 2.5) ;
		//drawing all the lines w/ varying lengths, colors, heights
		for (var i = 0; i < NUM_BARS; i++) {
			this.ctx.lineWidth = (1-i/NUM_BARS)*2+2;
			var alpha = 1.0-i/NUM_BARS*.9;
			this.ctx.strokeStyle = "rgba(0,255,213,"+alpha+")";
			this.ctx.beginPath();
      var arc = Math.max(.01, this.progress*(.4+.6*Math.pow(i/NUM_BARS, .8))+this.extras[i]);
      this.ctx.arc(0, (8+i/2)*i+197, 200, (-.5-arc/15*window.innerHeight/window.innerWidth)*Math.PI, (-.5+arc/15*window.innerHeight/window.innerWidth) * Math.PI);
			this.ctx.stroke();
		}
    this.ctx.restore();
	}
}

//What happens when the window loads
window.onload = function() {
	FRAME.init(1000,1000,document.getElementById("canvas"));
  
  //ORDER MATTERS.
  //Things draw ON TOP of one another, so sun is over starCollection, and logo is over sun and starCollection. 
  //Keep this in mind and add your stuff in the proper order.
  //NOTE: things in collections are drawn in the order they are added
  mainCollection = new Collection();
  mainCollection.add(new Stars());
  mainCollection.add(new Sun());
  mainCollection.add(new Logo());
  mainCollection.add(new MountainBottom());
  mainCollection.add(new LoadingBar());
	
	main(); //Run main
}

function Star(size, speed) {
  this.size = size;
  this.speed = speed;
  this.x = Math.random()-.5;
  this.y = Math.random()*.7 -.5;
}
class Stars extends Actor {
	constructor() {
		super();
		this.stars = [];
		for (var i = 0; i < STAR_COUNT; i++) {
		  var size = Math.random();
		  this.stars.push(new Star(size*MAX_STAR_SIZE, size*.0005+.00005));
		}
	}
	update() {
		for(var o in this.stars) {
		  var star = this.stars[o];
		  star.y -= star.speed;
		  if (star.y < -.5) {
			star.y = .7 - .5;
		  }
		  star.size = Math.max(.1, Math.min(MAX_STAR_SIZE, star.size+(Math.random()-.5)*STAR_TWINKLE_AMOUNT));
		}
		this.x = (-FRAME.x + window.innerWidth/2)/FRAME.scaleX;
		this.y = (-FRAME.y + window.innerHeight/2)/FRAME.scaleY;
	}
	  render() {
    this.ctx.fillStyle = "#90fff3";
    for(var o in this.stars) {
      var star = this.stars[o];
      var starX = (star.x*window.innerWidth/FRAME.scaleX);
      var starY = (star.y*window.innerHeight/FRAME.scaleY);
      this.ctx.fillRect(starX, starY, star.size, star.size);
    }
 }
}

function main() {
	FRAME.clearScreen(); //Refresh the screen. CLEAR THEM PIXELS, BOI
	
	//update crap
  mainCollection.update();
	
	//draw crap
  mainCollection.draw();
	
	//pretend to load something
	addLoadingProgress(0.0015);
	if (getLoadingProgress() > 1) {
		setLoadingProgress(1);
  }
	
	requestFrame(main);
}
    </script>



  
  




 
</body></html>